<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Porting to pure Bison API</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/code.css" />
        <link rel="stylesheet" type="text/css" href="../css/skylighting.css" />

        <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
        <link rel="alternate" type="application/rss+xml" href="../feed/rss.xml" title="RSS 2.0" />
        <link rel="shortcut icon" href="../images/favicon.ico" />
    </head>
    <body>
        <div id="navigation">
            <a href="../">home</a>
            <a href="../blog.html">blog</a>
            <a href="../feed/atom.xml">atom</a>
            <a href="../feed/rss.xml">rss</a>
            <a href="../about.html">about</a>
        </div>

        <div id="content">
            <h1>Porting to pure Bison API</h1>
            
                <div class="info">September  4, 2022</div>
            

            <p>A few weeks ago I started code cleanup for
<a href="https://github.com/trofi/ski/commits/master">Ski</a>.
Upstream <code>Ski</code> released in 2007 last time. I think it was actively
developed in 2003. That makes <code>Ski</code> about a 20 years old codebase.
It was more of a proof-of-concept makeshift project to help early
adopters than a piece of finished and maintained work. But it works
surprisingly good even today.</p>
<p>I would like to add a few medium sized features to <code>Ski</code>. I am a bit
afraid to make non-trivial changes. I decided to do do minor cleanup
first.</p>
<p>To deal with code health of old projects that I pretend to own (and thus
have the ability to do large cleanup changes) I have a few hacks
available. It mostly boils down to enabling a few compiler warnings to
use as suggestions for making things a bit more explicit.</p>
<p>I’ll outline some tricks I used for <code>Ski</code> and then will focus on
<code>Bison</code> API update.</p>
<h2 id="simple-tricks">Simple tricks</h2>
<p>C has a few language warts that allow you write code that is very likely
incorrect and yet standard compliant. A good example is implicit
function declaration behaviour. Luckily <code>gcc</code> has a set of warning to
catch those.</p>
<h3 id="implicit-variable-and-function-declarations">Implicit variable and function declarations</h3>
<p>To catch implicit function and variables <code>gcc</code> has at least the following
flags:</p>
<ul>
<li><code>-Werror=implicit-int</code></li>
<li><code>-Werror=implicit-function-declaration</code></li>
<li><code>-Werror=strict-prototypes</code></li>
</ul>
<p>I used these warnings successfully in
<a href="https://github.com/xmms2/xmms2-devel/commit/1dc66e4099e5b08f59bca86d7979f057fd82eba7">xmms2</a>,
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=80970472179a45609c0b11b80619bc8c32b15f77">linux kernel</a>
and and other projects.</p>
<p>Linux kernel is especially prone to these bugs as it heavily uses top
level macros a lot. lack of header inclusion for such a macro usually
turns macro call into a function declaration without any build failure.</p>
<p>Related build failures are still being fixed in <code>linux</code> kernel to this
day. Header inclusion changes are happening there all the time to speed
builds up and huge amount of <code>CONFIG</code> options increases the chance of
detting into a combination where a few headers got lost.</p>
<p>I’d say it’s a must have set of warning flags for a <code>C</code>-based project.</p>
<h3 id="modernized-configure.acmakefile.am">Modernized configure.ac/Makefile.am</h3>
<p>If the outdated project is <code>autotools</code>-based then chances are it uses
many deprecated and invalid constructs. Sometimes a project has complex
<code>./autogen.sh</code> script. My goal is usuallly to turn that script into a
single <code>autoreconf -i -f -W all</code> invocation. Ideally <code>configure.ac</code> and
<code>Makefile.am</code> should be enough to configure all the other details.
<code>-W all</code> helps catching deprecated macros and other lint errors.</p>
<p>For <code>Ski</code> I did the following changes:</p>
<ul>
<li>ported from autoconf <code>2.13</code>-ish to <code>autoconf-2.70</code></li>
<li>used <code>AC_CONFIG_AUX_DIR([build-aux])</code> to move most auxiliary files
into a <code>build-aux/</code> subdirectory</li>
<li>used <code>AM_SILENT_RULES([yes])</code> to make builds less verbose to make
warnings stand out</li>
<li>made <code>Makefile.am</code> non-recursive to make cross-directory dependencies
simpler</li>
<li>used <code>ACLOCAL_AMFLAGS = -I m4 -I macros --install</code> to vendor external
<code>m4</code> macros as separate <code>.m4</code> files instead of globbing them together
into a single <code>aclocal.m4</code></li>
</ul>
<h3 id="catch-inconsistent-function-prototypes-and-mark-functions-local">Catch inconsistent function prototypes and mark functions local</h3>
<p><code>Ski</code> is a bit special in a way it handles prototypes. For an example
file <code>foo.c</code> with <code>void foo(void)</code> function there was usually no
according <code>foo.h</code> available. Instead various <code>bar.c</code> and <code>baz.c</code> files
had their own local imports of <code>void foo(void)</code> duplicating the prototype.</p>
<p>The scheme has a few problems: build does not break when you change <code>foo()</code>’s
prototype in <code>foo.c</code> alone, 10x prototype duplication is common making
it harder to change, function prototypes don’t always agree on the
argument count a function has (<a href="https://github.com/trofi/ski/commit/c4de04f3b27424dd0caf5e89bf93ceab8cd59af1">example</a>).</p>
<p>To find such stray prototypes I use a few tricks:</p>
<ul>
<li>Use <code>-Wmissing-declarations</code> to detect cases where <code>foo.c</code> does
not have according header to include to verify prototype consistency.
That way I spot lack of <code>foo.h</code> headers, create them and consolidate
such prototype there. It’s also a good time to sprinkle <code>static</code>
keyword if a symbol happens to be used only in a single <code>.c</code> file.</li>
<li>Use <code>-flto</code> to detect prototype mismatches across such <code>.c</code> files.</li>
<li>Use <code>-Wunused-function -Wunused-variable</code> to detect unused
newly marked <code>static</code> functions.</li>
<li>Use <a href="https://trofi.github.io/posts/186-announce-uselex.rb-useless-exports-extinguisher.html">uselex.rb</a>
to spot more needlessly exported symbols to sprinkle even more <code>static</code>
annotations around.</li>
<li>Use <code>-ffunction-sections -fdata-sections -Wl,--gc-sections -Wl,--print-gc-sections</code>
to catch even more unused code and variables where <code>uselex.rb</code> was not
able to do it. Linkers are som much better at traversing graphs :)</li>
</ul>
<h3 id="make-headers-self-contained-and-minimal">Make headers self-contained and minimal</h3>
<p>When I start adding <code>#include "foo.h"</code> around I frequently notice that
some of them are incomplete and require including other headers themselves.
I usually use syntax-check the headers to fund such cases:</p>
<pre><code>$ for h in $(find -name '*.h'); do
    gcc -DHAVE_CONFIG_H=1 -fmax-errors=1 -I. -Isrc{,/decoder,/encoder} -fsyntax-only -c $h ||
      echo &quot;BROKEN H: $h&quot;
  done</code></pre>
<p>To get rid of unused header inclusions I usually use
<a href="https://github.com/include-what-you-use/include-what-you-use">include-what-you-use</a>.</p>
<h3 id="switch-from-lex-and-yacc-to-flex-and-bison-apis">Switch from lex and yacc to flex and bison APIs</h3>
<p><code>lex</code> and <code>yacc</code> interfaces have a few warts in their APIs. The major
one I would say is that both heavily use global variables to pass data
from one to another (and for user to write semantic actions):
<code>yylval</code>, <code>yyin</code>, <code>yyout</code> and a bunch of helper macros to work with them.</p>
<p>One of immediate benefits of switching from <code>yacc</code> to <code>bison</code> is ability
to enable <code>--warnings</code> reporting.
It is able to flag various grammar deciciencies like <a href="https://github.com/trofi/ski/commit/89c94225c3b4851f09daa54c5b0286a5726c6af0">this one</a>,
or <a href="https://github.com/skvadrik/re2c/commit/7e7c4b97af51f5e343faccacde2a58b9da5a1192">this one</a>.</p>
<p>More advanced benefit is the opportunity to switch to <code>pure</code> API: <code>pure</code> is the
one that uses function parameters to pass things around instead of global
variables. A few switch examples are <a href="https://github.com/trofi/ski/commit/5af00cd51f99127979280278f30cabd2de61d74a">this one</a>
and <a href="https://github.com/skvadrik/re2c/commit/8161d996f0ae0b7f782fff602bc261667c3e95d2">this one</a>.</p>
<p>The gist of it is move away from global <code>yylval</code> to explicit parameter threading.</p>
<h2 id="bison-apis">Bison APIs</h2>
<p>When I fist tried to switch <code>Ski</code> to <code>pure</code> <code>Bison</code> API I failed miserably.
I did not know what <code>Bison</code> generates, what <code>flex</code> generates and what
user is supposed to define. I also enabled function rename from <code>yy*()</code>
to <code>expr*()</code> and quickly got lost in errors and header inclusion cycles.</p>
<p>I stepped back and crafted simple pair of lexer and parser examples.
Then gradually upgraded them to modern world discovering minor API
gotchas one at a time.</p>
<p>The experience allowed me to finally port both <code>Ski</code> and <code>re2c</code> to more
modern <code>Bison</code> API.</p>
<h3 id="simple-example">Simple example</h3>
<p>Our running example will be the following trivial grammar:</p>
<pre><code>&lt;expression&gt; ::= &lt;digit&gt; | &lt;expression&gt; &quot;+&quot; &lt;digit&gt;
&lt;digit&gt; ::= &quot;0&quot; | &quot;1&quot; | ... | &quot;9&quot;</code></pre>
<p>It allows us write an expression of a digit (like <code>"1"</code> or <code>"2"</code>) or an
arbitrary sum of digits (like <code>"1+2+3"</code>). We will also allow whitespace
around.</p>
<p>We’ll need 3 files:</p>
<ul>
<li><code>Bison</code> parser: <code>p.y</code></li>
<li><code>Flex</code> lexer: <code>l.l</code></li>
<li><code>main()</code> function: <code>main.c</code></li>
</ul>
<p>Simple implementation would be the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat p.y */</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">%{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.expr.h&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">/* local declarations */</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> yyerror <span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> err<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">%}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="kw">union</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ival<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>token <span class="op">&lt;</span>ival<span class="op">&gt;</span> NUM</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>type <span class="op">&lt;</span>ival<span class="op">&gt;</span> expr</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>result <span class="op">:</span> expr       <span class="op">{</span> printf<span class="op">(</span><span class="st">&quot;RESULT: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> $<span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>expr <span class="op">:</span> NUM          <span class="op">{</span> $$ <span class="op">=</span> $<span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> expr <span class="ch">'+'</span> NUM <span class="op">{</span> $$ <span class="op">=</span> $<span class="dv">1</span> <span class="op">+</span> $<span class="dv">3</span><span class="op">;</span> printf<span class="op">(</span><span class="st">&quot;I-RESULT: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> $$<span class="op">);</span> <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>     <span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> yyerror <span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> err<span class="op">)</span> <span class="op">{</span> fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;PARSE ERROR: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> err<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p>Here we handle our grammar almost as it’s written in <code>BNF</code>. A few things
to note:</p>
<ul>
<li>Tokens are represented as instances of <code>union YYSTYPE { int ival; }</code>.
Usually tokens are more complicated and have a few more union
alternatives.</li>
<li>Our parse result is the <code>stdout</code> output of intermediate and final
computation step. We don’t collect any of the syntax information here.</li>
</ul>
<p>Note that parser’s definition requires lexing function prototype. Thus we
include all of autogenerated header via <code>#include "lex.expr.h"</code>.</p>
<p>Moving on to lexer:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat l.l */</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option noyywrap</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option nodefault</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">%{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parse.expr.h&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">%}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="op">[</span> \t\n<span class="op">]</span> <span class="op">{</span> <span class="co">/* skip whitespace */</span> <span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">[+]</span> <span class="op">{</span> <span class="cf">return</span> <span class="ch">'+'</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">0</span><span class="op">-</span><span class="dv">9</span><span class="op">]</span> <span class="op">{</span> yylval<span class="op">.</span>ival <span class="op">=</span> yytext<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> <span class="ch">'0'</span><span class="op">;</span> <span class="cf">return</span> NUM<span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="op">.</span> <span class="op">{</span> <span class="cf">return</span> YYUNDEF<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>The lexer is trivial:</p>
<ul>
<li>We support a few whitespace types (tab, space and newline). Whitespace
has no token representation. We just skip through them in this example.</li>
<li>Actual tokens are <code>'+'</code> operation (returned as is) and a digit returned
via <code>YYSTYPE yylval</code> global variable of type <code>union YYSTYPE { int ival; }</code>.</li>
</ul>
<p>Note that lexer’s implementation requires <code>union YYSTYPE</code> declaration provided
by <code>"parse.expr.h"</code> (while parser’s implementation clearly requires lexer’s
<code>yylex()</code>declaration). Thus we pull all of autogenerated lexer header via
<code>#include "parse.expr.h"</code>.</p>
<p>And our <code>main()</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat main.c */</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parse.expr.h&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span> argv<span class="op">[])</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Parsing input from stdin. Press ^D when finished.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    yyparse<span class="op">();</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s literally just one <code>yyparse()</code> call! Let’s build it:</p>
<pre><code>$ bison --warnings -Wcounterexamples --output=parse.expr.c --header=parse.expr.h --warnings p.y
$ flex --outfile=lex.expr.c --header-file=lex.expr.h l.l
$ gcc lex.expr.c parse.expr.c main.c -o example1</code></pre>
<p>The program happens to work on it’s stdin:</p>
<pre><code>$ ./example1
Parsing input from stdin. Press ^D when finished.
1       +2
I-RESULT: 3
+4
I-RESULT: 7
^D
RESULT: 7</code></pre>
<p>Here we typed <code>1+2+4</code> (with a bit of whitespace) and saw intermediate
results of <code>1+2</code> and intermediate/final result of the whole expression.</p>
<p>Fun fact: thanks to left recursion our grammar allows evaluating parts
of the expression before full expression is available.</p>
<p>Let’s have a peek at defined non-code symbols (data, rodata, undefined)
of generated files:</p>
<pre><code>$ gcc -c lex.expr.c
$ nm lex.expr.o | grep -v -P 't|T'
                 U clearerr
                 U ferror
                 U fileno
                 U fread
                 U free
                 U malloc
                 U realloc
0000000000000130 r yy_base
0000000000000048 b yy_c_buf_p
0000000000000190 r yy_chk
0000000000000150 r yy_def
0000000000000020 r yy_ec
0000000000000018 B yy_flex_debug
0000000000000040 b yy_hold_char
0000000000000008 B yyin
0000000000000000 B yyleng
0000000000000000 D yylineno
                 U yylval
0000000000000044 b yy_n_chars

$ gcc -c parse.expr.c
$ nm parse.expr.o | grep -v -P 't|T'
                 U free
                 U malloc
                 U memcpy
0000000000000000 B yychar
000000000000011b r yycheck
                 U yylex
0000000000000004 B yylval
0000000000000008 B yynerrs
0000000000000126 r yyr1
000000000000012b r yyr2</code></pre>
<p>Lexer defines quite a few globals: <code>yyin</code>, <code>yyleng</code>, <code>yylineno</code>, <code>yy_flex_debug</code>.
Parser does not define as many, but still has a few: <code>yychar</code>, <code>yylval</code>, <code>yynerrs</code>.</p>
<p>I did not realize it’s so much state scattered around.</p>
<h3 id="pure-example">Pure example</h3>
<p>Let’s now turn our example to string input (instead of <code>stdin</code> input)
and switch to pure API.</p>
<p>The main change is:</p>
<ul>
<li>add <code>%option reentrant bison-bridge</code> to <code>flex</code> lexer</li>
<li>add <code>%define api.pure full</code></li>
<li>make it all compile</li>
</ul>
<p>The above set of directives extends <code>int yylex(void)</code> with extra
parameters passed around. But not <code>yyparse()</code>! That will require
explicit extension with <code>%param {yyscan_t scanner}</code> (as it may be
lexer-dependenct).</p>
<p>Here is an updated parser:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat p.y */</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>define api<span class="op">.</span>pure full</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>param <span class="op">{</span>yyscan_t scanner<span class="op">}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>code requires <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typedef</span> <span class="dt">void</span> <span class="op">*</span> yyscan_t<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">%{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parse.expr.h&quot;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.expr.h&quot;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">/* local declarations */</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> yyerror <span class="op">(</span>yyscan_t scanner<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> err<span class="op">);</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="op">%}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="kw">union</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ival<span class="op">;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>token <span class="op">&lt;</span>ival<span class="op">&gt;</span> NUM</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>type <span class="op">&lt;</span>ival<span class="op">&gt;</span> expr</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>result <span class="op">:</span> expr       <span class="op">{</span> printf<span class="op">(</span><span class="st">&quot;RESULT: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> $<span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>expr <span class="op">:</span> NUM          <span class="op">{</span> $$ <span class="op">=</span> $<span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> expr <span class="ch">'+'</span> NUM <span class="op">{</span> $$ <span class="op">=</span> $<span class="dv">1</span> <span class="op">+</span> $<span class="dv">3</span><span class="op">;</span> printf<span class="op">(</span><span class="st">&quot;I-RESULT: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> $$<span class="op">);</span> <span class="op">}</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>     <span class="op">;</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> yyerror <span class="op">(</span>yyscan_t scanner<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> err<span class="op">)</span> <span class="op">{</span> fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;PARSE ERROR: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> err<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p>Compared to original example <code>%param {yyscan_t scanner}</code> extends
<code>yyparse()</code> declaration with <code>yyscan_t scanner</code> parameter (and also pass
it to every <code>yy*()</code> call including <code>yylex()</code>, <code>yyerror()</code> and many others).</p>
<p>We include extra <code>#include "parse.expr.h"</code> to make sure generated header
has the same prototype as <code>.c</code> file that implements it.</p>
<p>You might have noticed that <code>typedef void * yyscan_t;</code> bit. It unties
circular dependency between <code>"parse.expr.h"</code> header and <code>"lex.expr.h"</code>
header. Figuring out specific details of the dependency is an exercise
to the reader. Try to remove it and see what breaks. That error threw
me off when I initially tried <code>Ski</code> conversion.</p>
<p>Luckily <code>flex</code> guarantees that <code>yyscan_t</code> is an opaque type and will
always be <code>typedef void * yyscan_t;</code>. Thus we can open code it’s
declaration directly.</p>
<p>Note that we still print our results to <code>stdin</code>. In a real world example
you would probably want to pass another parameter to store final result via
something like <code>%parse-param {output_t * output}</code>.</p>
<p>Updated lexer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat l.l */</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">%{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parse.expr.h&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">%}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option warn</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option noyywrap</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option nodefault</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option reentrant</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>option bison<span class="op">-</span>bridge</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">[</span> \t\n<span class="op">]</span> <span class="op">{</span> <span class="co">/* skip whitespace */</span> <span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="op">[+]</span> <span class="op">{</span> <span class="cf">return</span> <span class="ch">'+'</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">0</span><span class="op">-</span><span class="dv">9</span><span class="op">]</span> <span class="op">{</span> yylval_param<span class="op">-&gt;</span>ival <span class="op">=</span> yytext<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> <span class="ch">'0'</span><span class="op">;</span> <span class="cf">return</span> NUM<span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="op">.</span> <span class="op">{</span> <span class="cf">return</span> YYUNDEF<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>Semantic action now uses <code>union YYSTYPE * yylval_param</code>. It is added by
<code>%option bison-bridge</code> to <code>yylex()</code> signature. <code>%option reentrant</code> has
another effect on the <code>yy*()</code> API: it adds <code>yyscan_t scanner</code> parameter.
Let’s look at the <code>yy*()</code> call site in <code>main()</code> function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $ cat main.c */</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parse.expr.h&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.expr.h&quot;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span> argv<span class="op">[])</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Parsing input from argv:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> argc<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;argv[</span><span class="sc">%i</span><span class="st">]='</span><span class="sc">%s</span><span class="st">':</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> argv<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        yyscan_t scanner<span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        YY_BUFFER_STATE buf<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        yylex_init <span class="op">(&amp;</span>scanner<span class="op">);</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        buf <span class="op">=</span> yy_scan_string <span class="op">(</span>argv<span class="op">[</span>i<span class="op">],</span> scanner<span class="op">);</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        yyparse<span class="op">(</span>scanner<span class="op">);</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        yy_delete_buffer<span class="op">(</span>buf<span class="op">,</span> scanner<span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        yylex_destroy <span class="op">(</span>scanner<span class="op">);</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here <code>flex</code>’s <code>%option reentrant</code> option requires us to thread
<code>yyscan_t scanner</code>. <code>scanner</code> holds full lexing context and does not
rely on any global variables.</p>
<p>The <code>YY_BUFFER_STATE buf; buf = yy_scan_string (..., scanner); yy_delete_buffer(buf, scanner);</code>
is the <code>flex</code> way to switch from <code>FILE *</code> based API to <code>const char *</code>
as an input buffer. It is not directly related to <code>Bison</code>’s <code>pure</code> API.</p>
<p>Let’s check out used globals now:</p>
<pre><code>$ gcc -c lex.expr.c
$ nm lex.expr.o | grep -v -P 't|T'
                 U clearerr
                 U ferror
                 U fileno
                 U fread
                 U free
                 U malloc
                 U realloc
0000000000000130 r yy_base
0000000000000190 r yy_chk
0000000000000150 r yy_def
0000000000000020 r yy_ec

$ gcc -c parse.expr.c
$ nm parse.expr.o | grep -v -P 't|T'
                 U free
                 U malloc
                 U memcpy
000000000000011b r yycheck
                 U yylex
0000000000000126 r yyr1
000000000000012b r yyr2</code></pre>
<p>No globals! <code>r</code> are static read-only lexer and parser tables. Yay!</p>
<h3 id="bonus-makefile-for-pure-example">Bonus: Makefile for pure example</h3>
<p>When I was working on an example I wanted to craft the <code>Makefile</code> that
tracks the dependencies precisely to rebuild all the artifacts. Be it
<code>Makefile</code>, <code>C</code> source, or input to any of generators change. Though
straightforward It ended up being wordy:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># $ cat makefile</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">FLEX</span> <span class="ch">=</span><span class="st"> flex</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">BISON</span> <span class="ch">=</span><span class="st"> bison</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">BISON_FLAGS</span> <span class="ch">=</span><span class="st"> --warnings -Wcounterexamples</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="dt">TARGETS</span> <span class="ch">=</span><span class="st"> a</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="dt">GENERATED_SOURCES</span> <span class="ch">=</span><span class="st"> lex.expr.c lex.expr.h parse.expr.c parse.expr.h</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="dt">OBJECTS</span> <span class="ch">=</span><span class="st"> lex.expr.o parse.expr.o main.o</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="dv">a:</span><span class="dt"> </span><span class="ch">$(</span><span class="dt">OBJECTS</span><span class="ch">)</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>	<span class="ch">$(</span><span class="dt">CC</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">LDFLAGS</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">OBJECTS</span><span class="ch">)</span> -o <span class="ch">$@</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co"># generator dependencies and rules</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="dv">lex.expr.c lex.expr.h:</span><span class="dt"> l.l</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>	<span class="ch">$(</span><span class="dt">FLEX</span><span class="ch">)</span> --outfile=lex.expr.c --header-file=lex.expr.h <span class="ch">$&lt;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="dv">parse.expr.c parse.expr.h:</span><span class="dt"> p.y</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>	<span class="ch">$(</span><span class="dt">BISON</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">BISON_FLAGS</span><span class="ch">)</span> --output=parse.expr.c --header=parse.expr.h --warnings <span class="ch">$&lt;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co"># extra build dependencies</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="dv">$(GENERATED_SOURCES) $(OBJECTS) $(TARGETS):</span><span class="dt"> Makefile</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="dv">lex.expr.o parse.expr.o:</span><span class="dt"> parse.expr.h</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="dv">parse.expr.o:</span><span class="dt"> lex.expr.h</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="dv">main.o:</span><span class="dt"> lex.expr.h parse.expr.h</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="ot">.PHONY:</span><span class="dt"> clean</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a><span class="dv">clean:</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>	<span class="ch">$(</span><span class="dt">RM</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">GENERATED_SOURCES</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">OBJECTS</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">TARGETS</span><span class="ch">)</span></span></code></pre></div>
<p>It took me a while to populate <code>extra build dependencies</code> section but
luckily <a href="http://trofi.github.io/posts/249-an-update-on-make-shuffle.html">make –shuffle</a>
kept finding the issues until I got something that works most of the time.
Looking at <code>-MMD</code> output I think it’s an accurate list of extra
dependencies on top of implicit <code>.c.o</code> ones.</p>
<h2 id="bison-version-requirements">Bison version requirements</h2>
<p><code>Bison</code>’s <code>--warnigns</code> flag was implemented in 2006, around <code>2.3a</code>
version. <code>%define api.pure</code> flag was implemented in 2007, around <code>2.3b</code>
version. Both should be safe to assume as widely available.</p>
<h2 id="parting-words">Parting words</h2>
<p>Pure <code>Bison</code> API is a nice cleanup to do for a project. It should not
take much code to implement: just add <code>%define api.pure full</code> and adapt
to API extension. The benefit is a slightly more explicit API readily
usable in multi-threaded and nested parser contexts.</p>
<p>Have fun!</p>
        </div>
    </body>
</html>
