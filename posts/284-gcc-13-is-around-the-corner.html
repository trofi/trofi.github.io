<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>gcc-13 is around the corner</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/code.css" />
        <link rel="stylesheet" type="text/css" href="../css/skylighting.css" />

        <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
        <link rel="alternate" type="application/rss+xml" href="../feed/rss.xml" title="RSS 2.0" />
        <link rel="shortcut icon" href="../images/favicon.ico" />
    </head>
    <body>
        <div id="navigation">
            <a href="../">home</a>
            <a href="../blog.html">blog</a>
            <a href="../log.html">log</a>
            <a href="../feed/atom.xml">atom</a>
            <a href="../feed/rss.xml">rss</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
        </div>

        <div id="content">
            <h1>gcc-13 is around the corner</h1>
            
                <div class="info">April 20, 2023</div>
            

            <p>It’s the end of April again and that means <code>gcc-13</code> will be released
very soon. Do check out <a href="https://gcc.gnu.org/gcc-13/porting_to.html">porting page</a>
to see what will likely cause problems for you on the upgrade. Most of
the issues listed there bit me over past year.</p>
<p>But that’s not the topic of this post. I kept using weekly <code>gcc</code>
snapshots of <code>master</code> branch for my desktop.</p>
<p>Since <a href="../posts/262-a-few-more-gcc-13-bugs.html">October 2022</a> I
encountered a few new bugs. Let’s look at some of them.</p>
<h3 id="gori-ice"><code>gori</code> <code>ICE</code></h3>
<p><a href="https://gcc.gnu.org/PR109274"><code>tree-optimization/109274</code></a>: <code>gcc</code> <code>ICE</code>
on <code>afdko</code>.</p>
<p>Minimal <code>afdko</code> crash:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> selfIsectPath_lo<span class="op">,</span> selfIsectPath_a<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> selfIsectPath_isecta<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> splitBez<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">float</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> p1 <span class="op">=</span> p1<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>a <span class="op">=</span> t <span class="op">*</span> t <span class="op">-</span> p1<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> checkSelfIsectCurve<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>p2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(*</span>p2 <span class="op">==</span> <span class="op">*</span>p2<span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> selfIsectPath<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> hi<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>selfIsectPath_lo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> hi <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    splitBez<span class="op">(&amp;</span>selfIsectPath_a<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    checkSelfIsectCurve<span class="op">(&amp;</span>selfIsectPath_a<span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>selfIsectPath_isecta<span class="op">)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      hi <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Triggering:</p>
<pre><code>$ gcc -O3 -c absfont_path.c.c -o a.o
during GIMPLE pass: evrp
absfont_path.c.c: In function 'selfIsectPath':
absfont_path.c.c:21:1: internal compiler error: Segmentation fault
   21 | }
      | ^
0xcb7c0f crash_signal
        gcc/toplev.cc:314
0x19682c4 range_def_chain::in_chain_p(tree_node*, tree_node*)
        gcc/gimple-range-gori.cc:126
0x19682c4 gori_compute::compute_operand_range(vrange&amp;, gimple*, vrange const&amp;, tree_node*, fur_source&amp;, value_relation*)
        gcc/gimple-range-gori.cc:667
0x19690d7 gori_compute::compute_operand1_range(vrange&amp;, gimple_range_op_handler&amp;, vrange const&amp;, tree_node*, fur_source&amp;, value_relation*)
        gcc/gimple-range-gori.cc:1174
0x1968165 gori_compute::compute_operand_range(vrange&amp;, gimple*, vrange const&amp;, tree_node*, fur_source&amp;, value_relation*)
        gcc/gimple-range-gori.cc:726
0x19698a7 gori_compute::compute_operand2_range(vrange&amp;, gimple_range_op_handler&amp;, vrange const&amp;, tree_node*, fur_source&amp;, value_relation*)
        gcc/gimple-range-gori.cc:1254
0x1969cf4 gori_compute::compute_operand1_and_operand2_range(vrange&amp;, gimple_range_op_handler&amp;, vrange const&amp;, tree_node*, fur_source&amp;, value_relation*)
        gcc/gimple-range-gori.cc:1274</code></pre>
<p>This is a crash in value range propagation subsystem. It’s expected to
derive various properties from comparisons and arithmetic. For example,
<code>*p2 == *p2</code> is probably always true as long as you can prove that <code>*p2</code>
is not a <code>NaN</code>. Unfortunately <code>gcc</code> did not consider specifics of <code>NaN</code>
in some places and managed to <code>SIGSEGV</code> itself.</p>
<p>Andrew explained the failure in more detail in
<a href="https://gcc.gnu.org/PR109274#c12">this comment</a>.</p>
<h2 id="wrong-code-on-byte-swapping">Wrong code on byte swapping</h2>
<p><a href="https://gcc.gnu.org/PR108064"><code>tree-optimization/108064</code></a>: <code>gcc</code>
wrong code on <code>apache-arrow-cpp</code>.</p>
<p>Minimal reproducer:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">short</span> <span class="dt">int</span> i16<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> i16 ByteSwap16<span class="op">(</span>i16 value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> m <span class="op">=</span> static_cast<span class="op">&lt;</span>i16<span class="op">&gt;(</span><span class="bn">0xff</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> static_cast<span class="op">&lt;</span>i16<span class="op">&gt;(((</span>value <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">&amp;</span> m<span class="op">)</span> <span class="op">|</span> <span class="op">((</span>value <span class="op">&amp;</span> m<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">8</span><span class="op">));</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>__attribute__<span class="op">((</span>noipa<span class="op">))</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swab16<span class="op">(</span>i16 <span class="op">*</span> d<span class="op">,</span> <span class="dt">const</span> i16<span class="op">*</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    d<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> ByteSwap16<span class="op">(</span>s<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>__attribute__<span class="op">((</span>noipa<span class="op">))</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* need to alogn inputs to make sure vectized part</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">     of the loop gets executed. */</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">alignas</span><span class="op">(</span><span class="dv">16</span><span class="op">)</span> i16 a<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="bn">0xff</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">alignas</span><span class="op">(</span><span class="dv">16</span><span class="op">)</span> i16 b<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">alignas</span><span class="op">(</span><span class="dv">16</span><span class="op">)</span> i16 c<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  swab16<span class="op">(</span>b<span class="op">,</span> a<span class="op">);</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  swab16<span class="op">(</span>c<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Contents of 'a' should be equivalent to 'c'.</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co">     But gcc bug generates invalid vectored shifts.  */</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">!=</span> c<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    __builtin_trap<span class="op">();</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Triggering the bug:</p>
<pre><code>$ ./gcc-git/bin/g++ -O3 a.cc -o a &amp;&amp; ./a
Illegal instruction (core dumped)
$ ./gcc-git/bin/g++ -O0 a.cc -o a &amp;&amp; ./a</code></pre>
<p>This example takes an array of 4 16-bit integers and swaps bytes in it
twice. We expect to get the same result as original. But we get
something else.</p>
<p>It took me a while to extract it from <code>apache-arrow</code> test suite but I’m
glad I spent a bit of time on it. Note how I had to use <code>alignas(16)</code>
hints to make sure runtime address of arrays has a nice 16-byte aligned
boundary. Otherwise, bug does not happen consistently. It’s a good hint
that vectorization is involved here.</p>
<p>If you have some familiarity with the <code>x86_64</code> assembler this snippet
shows mechanics of the bug:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; swab16(short*, short const*):</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>   <span class="op">(%</span><span class="kw">rsi</span><span class="op">),%</span><span class="kw">xmm0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">movdqa</span> <span class="op">%</span><span class="kw">xmm0</span><span class="op">,%</span><span class="kw">xmm1</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">psllw</span>  <span class="op">$</span><span class="bn">0</span>x8<span class="op">,%</span><span class="kw">xmm0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">psraw</span>  <span class="op">$</span><span class="bn">0</span>x8<span class="op">,%</span><span class="kw">xmm1</span> <span class="co">; &lt;&lt;&lt;- should be psrlw!</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">por</span>    <span class="op">%</span><span class="kw">xmm1</span><span class="op">,%</span><span class="kw">xmm0</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>   <span class="op">%</span><span class="kw">xmm0</span><span class="op">,(%</span><span class="kw">rdi</span><span class="op">)</span></span></code></pre></div>
<p>If the above code does not make sense it’s explanation is:</p>
<ul>
<li>load 16 bytes of input (more than our <code>u16</code> array) into <code>xmm0</code> from
<code>rsi</code> address</li>
<li>do <code>xmm0 = ((xmm0 &lt;&lt; 8) | (xmm0 &gt;&gt; 8))</code> equivalent to achieve byte
swap</li>
<li>write 8 bytes back (exactly our <code>u16</code> array) to <code>rdi</code> address</li>
</ul>
<p>This is yet another hint at <code>gcc</code> vectorization bug where <code>swab16()</code>
loop over <code>u16</code> values was widened to loop over <code>u64</code> values.</p>
<p>The problem happens in <code>&gt;&gt;</code> where arithmetic (sign-extending) shift is
used instead of logical (zero-extending) shift.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=33be3ee36a7e2c0be383ec01b5fbc9aef39568fd">The fix</a>
is trivial: use logical shift vectorization templates of this kind.</p>
<h2 id="initializer-list-failure">initializer list failure</h2>
<p><a href="https://gcc.gnu.org/PR108071"><code>c++/108071</code></a>: <code>gcc</code> failed to build
<code>clang</code>.</p>
<p>Minimal reproducer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OptSpecifier<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ArrayRef <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  ArrayRef<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>OptSpecifier<span class="op">&gt;);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> OptSpecifier <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span> OptSpecifier<span class="op">(</span><span class="dt">bool</span><span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  OptSpecifier<span class="op">(</span><span class="dt">unsigned</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ArgList <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> AddAllArgs<span class="op">(</span>ArrayRef<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span> OPT_u <span class="op">};</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Linker <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> ConstructJob<span class="op">(</span><span class="at">const</span> ArgList <span class="op">&amp;)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Linker<span class="op">::</span>ConstructJob<span class="op">(</span><span class="at">const</span> ArgList <span class="op">&amp;</span>Args<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  Args<span class="op">.</span>AddAllArgs<span class="op">({</span>OPT_u<span class="op">});</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And build failure:</p>
<pre><code>$ g++ -c bug.cc.cc
bug.cc.cc: In member function 'void Linker::ConstructJob(const ArgList&amp;) const':
bug.cc.cc:19:18: error: call of overloaded 'OptSpecifier(const&lt;unnamed enum&gt;)' is ambiguous
   19 |   Args.AddAllArgs({OPT_u});
      |   ~~~~~~~~~~~~~~~^~~~~~~~~
bug.cc.cc:9:3: note: candidate: 'OptSpecifier::OptSpecifier(unsigned int)'
    9 |   OptSpecifier(unsigned);
      |   ^~~~~~~~~~~~
bug.cc.cc:8:12: note: candidate: 'OptSpecifier::OptSpecifier(bool)'
    8 |   explicit OptSpecifier(bool);
      |            ^~~~~~~~~~~~
bug.cc.cc:7:8: note: candidate: 'constexpr OptSpecifier::OptSpecifier(const OptSpecifier&amp;)'
    7 | struct OptSpecifier {
      |        ^~~~~~~~~~~~
bug.cc.cc:7:8: note: candidate: 'constexpr OptSpecifier::OptSpecifier(OptSpecifier&amp;&amp;)'</code></pre>
<p>It’s a <code>c++</code> frontend bug in handling of initializer lists. I don’t
pretend to understand <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=4ef521bbc63f8a3883d507a8b6c1f95f442df3fe">the fix</a>.
Looks like a kind of implicit conversion handling was missing there.</p>
<h2 id="more--wdangling-reference-false-positives">More <code>-Wdangling-reference</code> false positives</h2>
<p><a href="https://gcc.gnu.org/PR107488"><code>c++/107488</code></a>: <code>cppunit</code> exposed a false
positive in recently added <code>gcc</code> warning.</p>
<p>A while before I <a href="../posts/264-gcc-s-new-Wdangling-reference-warning.html">saw</a> a
a few other examples of false positives in this area. Here is another one:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> attributesAsString<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> attributes<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator itAttribute <span class="op">=</span> v<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span> itAttribute <span class="op">!=</span> v<span class="op">.</span>end<span class="op">()</span> <span class="op">)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> <span class="op">&amp;</span>attribute <span class="op">=</span> <span class="op">*</span>itAttribute<span class="op">++;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    attributes <span class="op">+=</span> attribute<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> attributes<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Triggering the warning:</p>
<pre><code>$ g++ -Werror=dangling-reference -c a.cpp.cpp -o a.o
a.cpp.cpp: In function 'int attributesAsString(std::vector&lt;int&gt;&amp;)':
a.cpp.cpp:12:16: error: possibly dangling reference to a temporary [-Werror=dangling-reference]
   12 |     const int &amp;attribute = *itAttribute++;
      |                ^~~~~~~~~
a.cpp.cpp:12:40: note: the temporary was destroyed at the end of the full expression
  'itAttribute.__gnu_cxx::__normal_iterator&lt;const int*, std::vector&lt;int&gt; &gt;::operator++(0).__gnu_cxx::__normal_iterator&lt;const int*, std::vector&lt;int&gt; &gt;::operator*()'
   12 |     const int &amp;attribute = *itAttribute++;
      |                                        ^~</code></pre>
<p>It’s a reasonable code without a chance to leak something unexpected.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=32a06ce38a38bf37db468f0e6c83520fcc221534">The fix</a>
special-cased <code>operator*()</code> as not creating short-lived temporaries.</p>
<p><a href="https://gcc.gnu.org/PR109514"><code>c++/109514</code></a> was a similar case in
<code>fheroes2</code> codebase.</p>
<h2 id="fanalyzer-crash-on-bind-function"><code>-fanalyzer</code> crash on <code>bind()</code> function</h2>
<p><a href="https://gcc.gnu.org/PR107783"><code>analyzer/107783</code></a>: <code>gnutls</code> triggered
<code>ICE</code> in <code>-fanalyzer</code> mode.</p>
<p>This time the reproducer is tiny:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>foo <span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> bind <span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<pre><code>$ gcc -fanalyzer -c oerlsfmf.c
during IPA pass: analyzer
oerlsfmf.c: In function 'foo':
oerlsfmf.c:4:10: internal compiler error: in deref_rvalue, at analyzer/region-model.cc:3238
    4 |   return bind (0, 0, 0);
      |          ^~~~~~~~~~~~~~</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=12a4785c9120beeef42f1bded52cc2674e206f57">The fix</a>
corrected type annotation for <code>bind()</code> in analyzer’s model of functions
working with file descriptors.</p>
<h2 id="ice-in-implicit-type-conversions"><code>ICE</code> in implicit type conversions</h2>
<p><a href="https://gcc.gnu.org/PR108047"><code>c++/108047</code></a>: <code>arrow-cpp</code> triggered <code>gcc</code>
<code>ICE</code>.</p>
<p>Small reproducer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> format_underline<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> parse_key_value_pair<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span> format_underline<span class="op">({</span><span class="st">&quot;&quot;</span><span class="op">});</span> <span class="op">}</span></span></code></pre></div>
<p>And the crash:</p>
<pre><code>$ g++ -c bug.cc
...
bug.cc: In function 'void parse_key_value_pair()':
bug.cc:7:51: internal compiler error:
  unexpected expression '(std::__cxx11::basic_string&lt;char&gt;)&quot;&quot;' of kind implicit_conv_expr
    7 | void parse_key_value_pair(void) { format_underline({&quot;&quot;}); }
      |                                   ~~~~~~~~~~~~~~~~^~~~~~
  diagnostic_impl(rich_location*, diagnostic_metadata const*, int, char const*, __va_list_tag (*) [1], diagnostic_t)
  internal_error(char const*, ...)
  cxx_eval_constant_expression(constexpr_ctx const*, tree_node*, value_cat, bool*, bool*, tree_node**)</code></pre>
<p>Here <code>gcc</code> could not figure out the type of constant expression in the
frontend and crashed.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=01ea66a6c56e53163d9430f4d87615d570848aa8">The fix</a>
amends it. I don’t understand it either. It has something to do with
initializer lists and templates :)</p>
<p>This was a popular failure. <code>nix</code> also <code>ICE</code>d <code>gcc</code> the same way.</p>
<h2 id="float-vectors-and-implicit-conversions"><code>float</code> vectors and implicit conversions</h2>
<p><code>[c++/107358</code>](https://gcc.gnu.org/PR107358): <code>gcc</code> failed to compile
<code>libjxl</code>.</p>
<p>Minimized example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this works:</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> approx_scal<span class="op">(</span><span class="dt">float</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> e <span class="op">-</span> <span class="fl">124.225514990</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">float</span> <span class="ex">__attribute__((vector_size(4*sizeof(float)))</span><span class="op">)</span> F<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">// this fails:</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>F approx_vec<span class="op">(</span>F e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> e <span class="op">-</span> <span class="fl">124.225514990</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Did you know you can do <code>operator-()</code> against <code>float</code> vectors? I did
not. The trigger looked this way:</p>
<pre><code>$ g++ -fPIC -std=c++11 -o skcms.cc.o -c skcms.cc
skcms.cc: In function 'F approx_vec(F)':
   10 | F approx_vec(F e) {
      |                 ^
skcms.cc:11:14: error: conversion of scalar 'long double' to vector 'F' {aka '__vector(4) float'} involves truncation
   11 |     return e - 124.225514990f;
      |            ~~^~~~~~~~~~~~~~~~</code></pre>
<p>Even though all the arguments are of <code>float</code> type <code>gcc</code> pulled out
<code>double</code> conversion and failed.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=65e3274e363cb2c6bfe6b5e648916eb7696f7e2f">The fix</a>
added expected precision to the type checker frontend.</p>
<h2 id="implicit-construction-on-assignment">implicit construction on assignment</h2>
<p><a href="https://gcc.gnu.org/PR109307"><code>c++/109247</code></a>: <code>gcc</code> failed to compile
<code>webkitgtk</code>.</p>
<p>Minimal example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;variant&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RefGradient <span class="op">{};</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RefPattern <span class="op">{};</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AffineTransform <span class="op">{};</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SourceBrush <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Brush <span class="op">{</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> LogicalGradient <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            RefGradient gradient<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            AffineTransform spaceTransform<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>variant<span class="op">&lt;</span>LogicalGradient<span class="op">,</span> RefPattern<span class="op">&gt;</span> brush<span class="op">;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setGradient<span class="op">(</span>RefGradient <span class="op">&amp;&amp;,</span> <span class="at">const</span> AffineTransform <span class="op">&amp;</span> spaceTransform <span class="op">=</span> <span class="op">{</span> <span class="op">});</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setPattern<span class="op">(</span>RefPattern <span class="op">&amp;&amp;);</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Brush<span class="op">&gt;</span> <span class="va">m_brush</span><span class="op">;</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> SourceBrush<span class="op">::</span>setGradient<span class="op">(</span>RefGradient<span class="op">&amp;&amp;</span> gradient<span class="op">,</span> <span class="at">const</span> AffineTransform<span class="op">&amp;</span> spaceTransform<span class="op">)</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_brush</span> <span class="op">=</span> <span class="op">{</span> Brush<span class="op">::</span>LogicalGradient <span class="op">{</span> <span class="bu">std::</span>move<span class="op">(</span>gradient<span class="op">),</span> spaceTransform <span class="op">}</span> <span class="op">};</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> SourceBrush<span class="op">::</span>setPattern<span class="op">(</span>RefPattern<span class="op">&amp;&amp;</span> pattern<span class="op">)</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_brush</span> <span class="op">=</span> <span class="op">{</span> <span class="bu">std::</span>move<span class="op">(</span>pattern<span class="op">)</span> <span class="op">};</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The trigger:</p>
<pre><code>$ g++ SourceBrush.cpp -c -std=c++20
SourceBrush.cpp: In member function 'void SourceBrush::setGradient(RefGradient&amp;&amp;, const AffineTransform&amp;)':
SourceBrush.cpp:28:80: error: converting to 'std::optional&lt;SourceBrush::Brush&gt;' from initializer list would use explicit constructor 'constexpr std::optional&lt;_Tp&gt;::optional(_Up&amp;&amp;) [with _Up = SourceBrush::Brush::LogicalGradient; typename std::enable_if&lt;__and_v&lt;std::__not_&lt;std::is_same&lt;std::optional&lt;_Tp&gt;, typename std::remove_cv&lt;typename std::remove_reference&lt;_Iter&gt;::type&gt;::type&gt; &gt;, std::__not_&lt;std::is_same&lt;std::in_place_t, typename std::remove_cv&lt;typename std::remove_reference&lt;_Iter&gt;::type&gt;::type&gt; &gt;, std::is_constructible&lt;_Tp, _Up&gt;, std::__not_&lt;std::is_convertible&lt;_Up, _Tp&gt; &gt; &gt;, bool&gt;::type &lt;anonymous&gt; = false; _Tp = SourceBrush::Brush]'
   28 |     m_brush = { Brush::LogicalGradient { std::move(gradient), spaceTransform } };
      |                                                                                ^</code></pre>
<p>It’s a long but straightforward error: <code>gcc</code> stopped inferring <code>Brush</code>
outer constructor. So far the consensus that it’s not a <code>gcc-13</code> bug
but a bug in previous versions of <code>gcc</code> to accept this code.</p>
<p>The fix should look like:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">--- a/SourceBrush.cpp</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">+++ b/SourceBrush.cpp</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -50,10, +50,10</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a> void SourceBrush::setGradient(RefGradient&amp;&amp; gradient, const AffineTransform&amp; spaceTransform)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="st">-     m_brush =       { Brush::LogicalGradient { std::move(gradient), spaceTransform } };</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="va">+     m_brush = Brush { Brush::LogicalGradient { std::move(gradient), spaceTransform } };</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a> void SourceBrush::setPattern(RefPattern&amp;&amp; pattern)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="st">-     m_brush =       { std::move(pattern) };</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="va">+     m_brush = Brush { std::move(pattern) };</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<h2 id="ice-in-ipa-clone"><code>ICE</code> in <code>ipa-clone</code></h2>
<p><a href="https://gcc.gnu.org/PR108110"><code>ipa/108110</code></a>: <code>gcc</code> <code>ICE</code>d on <code>minetest</code>
code.</p>
<p>The minimal example I came up with was:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> __throw_out_of_range_fmt<span class="op">(...);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>_M_p<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Trans_NS___cxx11_basic_string <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> _M_string_length<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> _M_check___pos<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  Trans_NS___cxx11_basic_string<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> __length <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    _M_string_length <span class="op">=</span> __length<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> size<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> _M_string_length<span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> foo___pos<span class="op">;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> foo<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> _M_p<span class="op">[</span>foo___pos<span class="op">];</span> <span class="op">}</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> compare<span class="op">()</span> <span class="op">{</span> __throw_out_of_range_fmt<span class="op">(</span>_M_check___pos<span class="op">,</span> _M_string_length<span class="op">);</span> <span class="fu">__builtin_trap</span><span class="op">();</span> <span class="op">}</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> str_starts_with<span class="op">(</span>Trans_NS___cxx11_basic_string <span class="op">&amp;</span>str<span class="op">,</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>                     Trans_NS___cxx11_basic_string prefix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>str<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> prefix<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    str<span class="op">.</span>compare<span class="op">();</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> prefix<span class="op">.</span>size<span class="op">();)</span> <span class="op">{</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> __trans_tmp_2 <span class="op">=</span> prefix<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>__trans_tmp_2<span class="op">)</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">__builtin_trap</span><span class="op">();</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> testStartsWith<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  Trans_NS___cxx11_basic_string s1<span class="op">,</span> s2<span class="op">;</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>  str_starts_with<span class="op">(</span>s1<span class="op">,</span> s2<span class="op">);</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And the trigger is:</p>
<pre><code>$ g++ -Wall -Wextra  -O3  -c bug.cc
during IPA pass: inline
bug.cc: In function 'void testStartsWith()':
bug.cc:28:18: internal compiler error: in modify_call, at ipa-param-manipulation.cc:700
   28 |   str_starts_with(s1, s2);
      |   ~~~~~~~~~~~~~~~^~~~~~~~
  diagnostic_impl(rich_location*, diagnostic_metadata const*, int, char const*, __va_list_tag (*) [1], diagnostic_t)
  internal_error(char const*, ...)
  fancy_abort(char const*, int, char const*)
  ipa_param_adjustments::modify_call(cgraph_edge*, bool) [clone .cold]
  cgraph_edge::redirect_call_stmt_to_callee(cgraph_edge*)
  redirect_all_calls(copy_body_data*, basic_block_def*)
  copy_body(copy_body_data*, basic_block_def*, basic_block_def*, basic_block_def*) [clone .isra.0]
  expand_call_inline(basic_block_def*, gimple*, copy_body_data*, bitmap_head*)
  optimize_inline_calls(tree_node*)
  inline_transform(cgraph_node*)
  execute_all_ipa_transforms(bool)
  cgraph_node::expand()
  symbol_table::compile() [clone .part.0]
  symbol_table::finalize_compilation_unit()</code></pre>
<p>Here <code>gcc</code> backtrace is very clear: optimization inlined the function
call and tried to redirect the calls to resulting function after the
inline is performed. But something went wrong.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=c389991432da2bcc335a2b4fb7e502d28a6b3346">The fix</a>
enhances resolution of original function arguments to survive various
transformations so the replacement would be correct in all contexts.</p>
<h1 id="parting-words">Parting words</h1>
<p>Again, most of the <code>gcc</code> bugs were fixed within a week they were
introduced. It’s amazing.</p>
<p>While I encountered most of the bugs I reported only minority of them as
someone else already discovered them first.</p>
<p>Partly it was because I was updating weekly snapshots on Sunday nights
(when the snapshots are cut). While the bugs are introduced during the
week. As I don’t have much time to explore complicated <code>gcc</code> bugs on
weekdays it usually takes me the time until next weekend to look into
failures. That is almost 2 weeks of lag from introduction to report.
It’s not ideal for everyone: devs might have moved on to another problem
and brave users started encountering the bug in the wild.</p>
<p>To think of it, I found handling snapshots a bit clunky to manage
short-lived backports locally until next snapshot is cut. It’s the very
same reason I never published snapshots as distribution packages myself
for other users: they are always slightly stale. Using <code>git</code> branches
is a bit easier.</p>
<p>I started using weekly <code>gcc</code> snapshots at the time (and not just <code>gcc</code>
from <code>git</code>) only because I did not know how to bootstrap my <code>NixOS</code>
system with <code>gcc</code> that needs <code>git</code> in its dependencies. A year has
passed and I know how to do it now! Let’s see if I’ll be able to catch
bugs faster as a result.</p>
<p>If you are feeling brave and you are ready to trace and report <code>gcc</code>
bugs like the above do consider giving unreleased versions of <code>gcc</code> a
try. You might learn a thing or two in the process.</p>
<p>The wrong-code bugs are the subtlest. These usually live for a while
until they get noticed. They take time to get extracted and understood.
But they are most rewarding to understand and to fix!</p>
<p><code>gcc-13</code> development is almost done. It will require quite a bit of
<code>#include &lt;cstdint&gt;</code> header sprinkling. My local system still has about
30 packages fixed pending upstream inclusion. I hope that official
<code>gcc-13</code> release will help upstream developers to adapt faster.</p>
<p>Looking at the bug list above the histogram of most failing subsystems
is:</p>
<ul>
<li><code>c++</code>: 5</li>
<li><code>tree-optimization</code>: 2</li>
<li><code>analyzer</code>: 1</li>
<li><code>ipa</code>: 1</li>
</ul>
<p>As I don’t get exposed to exotic arches nowadays it’s natural I don’t
see many bugs in their backends either. Thus, <code>c++</code> frontend is by far
the most frequent to cause issues. And it certainly feels that way. That
is a good indicator that <code>C++</code> as a language still evolves substantially.</p>
<p>Overall <code>gcc-13</code> should be a smooth sailing similar to <code>gcc-12</code> (famous
last words).</p>
<p>As usual here is a list of notable changes for upcoming release:
<a href="https://gcc.gnu.org/gcc-13/changes.html" class="uri">https://gcc.gnu.org/gcc-13/changes.html</a></p>
<p>Have fun!</p>
        </div>
    </body>
</html>
