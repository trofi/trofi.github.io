<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>trofi's blog: ia64 ptrace: off-by-one yak</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/code.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlighting-kate.css" />

        <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
        <link rel="alternate" type="application/rss+xml" href="../feed/rss.xml" title="RSS 2.0" />
        <link rel="shortcut icon" href="../images/favicon.ico" />
    </head>
    <body>
        <div id="header">
            <a href="../">main :: IO ()</a>
        </div>
        <div id="navigation">
            <a href="../">/root</a>
            <a href="../archive.html">/archive</a>
            <a href="../feed/atom.xml">/atom.xml</a>
            <a href="../feed/rss.xml">/rss.xml</a>
        </div>

        <div id="content">
            <h1>ia64 ptrace: off-by-one yak</h1>

            <p>Gentoo has one alive <strong>ia64</strong> machine: <strong>HP rx3600</strong> nicknamed <strong>guppy</strong>.
It’s an old box, and yet it’s specs are not too different from my
10 years old desktop: 32 GB RAM, 2 cores x 2 hyperthreads each.</p>
<p>Thus it’s suitable for on-host debugging of all sorts up to building
and running <strong>gcc</strong> testsuites or remote X client apps like pre-rust
version of firefox.</p>
<h1 id="kernel-upgrade">kernel upgrade</h1>
<p>There were a few major upstream kernel changes that made me a bit
nervous to update kernel on that machine from <strong>4.9</strong>:</p>
<ul>
<li><strong>cciss</strong> SCSI driver was removed in favour of <strong>hpsa</strong> one
(which among other things changed <strong>/dev/</strong> paths for device)</li>
<li>large scale memory management cleanups broke kernel build on
<strong>ia64</strong> for some memory models and that slipped to release tarball
prompting questions of <strong>ia64</strong> support status.</li>
</ul>
<p>Fast forward a few years and we were running <strong>4.9</strong> kernel in 2021.
Whoops. No fancy new <strong>statx()</strong> syscalls or modern container whistles.</p>
<p>Also John Paul Adrian started asking question if Gentoo were seeing
NUMA-related boot failures. I decided to upgrade a kernel to one of
recent releases.</p>
<p>First I attempted to upgrade straight to then most recent <strong>5.10</strong> (it
took me a while to write about it). Built <strong>5.10</strong> and booted
it without any problems (<strong>grub</strong>++ for ease of messing with <strong>root=</strong>
over BMC). I rebuilt a few hevyweight packages to check basic ability
to roll back if needed. No problems! Phew! End of the story!</p>
<p>Or not.</p>
<h1 id="the-quest-of-strace">the quest of strace</h1>
<p>A few days after kernel upgrade Dmitry (<strong>strace</strong> upstream maintainer)
reported a bug uncovered by <strong>strace</strong> testsuite: <a href="https://bugs.gentoo.org/769614">https://bugs.gentoo.org/769614</a>.
Many tests started failing for invalid syscall parameters as seen by
<strong>ptrace()</strong>.</p>
<p>Dmitry noticed that sometimes syscall parameters were off-by-one:</p>
<ul>
<li>expected: sys_foo(a1,a2,a3,…)</li>
<li>observed: sys_foo(__NR_foo,a1,a2,a3,…)</li>
</ul>
<p>Looks like a trivial bug, right?</p>
<p>Quiz: pause here for a minute and try to guess the nature of this bug.
It’s ok (and encouraged!) not to have any prior knowledge of kernels,
<strong>ptrace()</strong> facility or <strong>ia64</strong> architecture.</p>
<p>What kind of kernel change could trigger failures and what was the real
cause of the observed discrepancy? A few distractors to chose for you:</p>
<ul>
<li>mechanical coding bug in recent kernel (like using wrong register during
unwind)</li>
<li>subtle failed assumption like stack handling direction or syscall argument
passing</li>
<li>a dormant <strong>strace</strong> bug</li>
<li>CPU hardware failure</li>
<li>something else</li>
</ul>
<h1 id="the-clues">the clues</h1>
<p>At first I thought it to be a simpler form of
<a href="../posts/211-page-fault-handling-on-alpha.html">alpha’s off-by-one bug</a> where we
encoded incorrect offsets to <strong>struct pt_regs</strong>.</p>
<p>The fun and scary thing about <strong>ia64</strong> compared to many other arches
is that it’s use of <strong>pt_regs</strong> is a lot more <a href="../posts/210-ptrace-and-accidental-boot-fix-on-ia64.html">involved</a>:
register access requires kernel stack unwindind up to the userspace boundary.
But complex unwinnding also happens to make it more uniform compared to other arches:
most of the time you just use slow unwinder instead of hardcoding anything
fast or special cased.</p>
<p>I hoped the fix would be a simpler variant of the alpha bug. With that bit of
experience I hoped it would help.</p>
<p>The presence of unexpected syscall number in syscall parameters for
<strong>ptrace()</strong> bothered me a bit. Why does it appear in such a strange
place?</p>
<p>I skimmed through <strong>arch/ia64</strong> kernel commits in <strong>4.9..5.10</strong> range related
to <strong>ptrace()</strong>, found 5 of them, stared a lot at them and did not find anything
suspicious.</p>
<p>Then I skimmed through kernel’s side of intercepting syscall parameters. I looked
at a <strong>break</strong> trapping instruction handling. <strong>break</strong> instruction is similar
to <strong>x86</strong>’s <strong>int</strong>: it trigger interrupt style switch to kernel context. With
a caveat that everything on <strong>ia64</strong> is special.</p>
<p><strong>ptrace()</strong> handling path looked straightforward:</p>
<p>Tracee:</p>
<ul>
<li>entry point is <strong>ENTRY(break_fault)</strong> (at <strong>arch/ia64/kernel/ivt.S</strong>)
<ul>
<li>save only part of <strong>struct pt_regs</strong></li>
<li><strong>GLOBAL_ENTRY(ia64_trace_syscall)</strong> (at <strong>arch/ia64/kernel/entry.S</strong>):
<ul>
<li><strong>PT_REGS_SAVES</strong>: create new frame worth of <strong>struct pt_regs</strong></li>
<li><strong>f6-f11</strong> FPUs regs are saved</li>
<li><strong>syscall_trace_enter</strong> (asm-&gt;C boundary is crossed here, registers are
passed as arguments) (at <strong>arch/ia64/kernel/ptrace.c</strong>)
<ul>
<li><strong>tracehook_report_syscall_entry</strong> communicates state to tracer</li>
<li>tracer resumes and gets data</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>Tracer:</p>
<ul>
<li><strong>ptrace_get_syscall_info_entry</strong>
<ul>
<li><strong>info-&gt;entry.nr = syscall_get_nr(child, regs);</strong> // regs-&gt;r15</li>
</ul></li>
</ul>
<p>The complication here is to find out which of two paths is buggy:
tracer path or tracee path? Tracee path looks more involved and
has a higher chance to fail. I needed to poke at a real example
to match expected and observed states.</p>
<p>I attempted to reproduce the bug on <strong>strace</strong> test suite and
instantly got the same result. Yay! Sharing the machine with
the reporter is very convenient :)</p>
<p>I started sprinkling <strong>printk()</strong> statement all over the kernel.
Most interesting result was for <strong>syscall_get_set_args_cb()</strong> in
<strong>arch/ia64/kernel/ptrace.c</strong>.</p>
<pre class><code>syscall_get_set_args_cb: krbs: 0xe000000103800ec0
syscall_get_set_args_cb: ndirty: 0x0
syscall_get_set_args_cb: count: 6
syscall_get_set_args_cb: krbs[0]: 0x40a
syscall_get_set_args_cb: krbs[1]: 0x2000000800122590
syscall_get_set_args_cb: krbs[2]: 0xbad1fed1
syscall_get_set_args_cb: krbs[3]: 0xbad2fed2
syscall_get_set_args_cb: krbs[4]: 0xbad3fed3
syscall_get_set_args_cb: krbs[5]: 0xbad4fed4
syscall_get_set_args_cb:args[0]: 0x40a
syscall_get_set_args_cb:args[1]: 0x2000000800122590
syscall_get_set_args_cb:args[2]: 0xbad1fed1
syscall_get_set_args_cb:args[3]: 0xbad2fed2
syscall_get_set_args_cb:args[4]: 0xbad3fed3
syscall_get_set_args_cb:args[5]: 0xbad4fed4</code></pre>
<p>Here <strong>krbs</strong> is kernel’s register backing store in memory.</p>
<p><strong>RBS</strong> memory area (pointed at <strong>ar.bsp</strong> and <strong>ar.bspstore</strong> registers)
is where rotating registers are spilled on user’s request or automatically.
In case of <strong>ptrace()</strong> registers are spilled on kernel’s request with
<strong>flushrs</strong> instruction to make sure we can read them from memory.</p>
<p>Normally <strong>krbs</strong> should contain syscall arguments and maybe
local function variables. <strong>args</strong> array is actual syscall args.
We still see <strong>0x402</strong> (<strong>__NR_read</strong>) as first argument. That is probably
a manifestation of the bug we trace.</p>
<p>Fun fact: for some reason <strong>ia64</strong> linux syscalls start from 1024
(<strong>0x400</strong>). Perhaps lower numbers are reserved for binary
compatibility with <strong>HPUX</strong>?</p>
<h1 id="bisecting-the-kernel">bisecting the kernel</h1>
<p>I still did not get anything obvious. Why did syscall number kept
getting in the list? I decided to bisect the kernel.</p>
<p>I rebooted back to <strong>4.9</strong> kernel and made sure that bug disappeared.
Ok, that meant it’s not at least some parallel userspace update.</p>
<p>I bisected the kernel down to the following commit:</p>
<pre class><code>commit 201766a20e30f982ccfe36bebfad9602c3ff574a
Author: Elvira Khabirova &lt;lineprinter@altlinux.org&gt;
Date:   Tue Jul 16 16:29:42 2019 -0700

  ptrace: add PTRACE_GET_SYSCALL_INFO request

  PTRACE_GET_SYSCALL_INFO is a generic ptrace API that lets ptracer obtain
  details of the syscall the tracee is blocked in.

 include/linux/tracehook.h                     |   9 ++++++---
 include/uapi/linux/ptrace.h                   |  35 +++++++++++++++++++++++++++++++++++
 kernel/ptrace.c                               | 101 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 tools/testing/selftests/seccomp/seccomp_bpf.c |  13 +++++++++----
 4 files changed, 150 insertions(+), 8 deletions(-)</code></pre>
<p>Tl;DR is: it’s a new <strong>ptrace()</strong> API to fetch traced syscall arguments.</p>
<p>This means it’s not strictly a regression of existing code:</p>
<ul>
<li>before the kernel change <strong>strace</strong> used to manually
extract syscall arguments from <strong>ptrace(PTRACE_GETREGS)</strong>
knowing the syscall ABI for an architecture</li>
<li>after the change it calls <strong>ptrace(PTRACE_GET_SYSCALL_INFO)</strong> and gets
all the arguments as a nice portable array. No need to deal with register
numbers!</li>
</ul>
<p>That looked even more confusing! Arch-specific <strong>ptrace()</strong> code was not changed
in that commit and yet some part of <strong>ptrace()</strong> is somehow broken.
It meant that something was probably broken forever.</p>
<p>What next? I had to fall back to debugging the issue from the first
principles: carefully trace syscall entry into the kernel to debug
<strong>ptrace()</strong> hook being called and check how syscall arguments are
extracted.</p>
<p>Sounds tedious but straightforward.</p>
<h1 id="syscalls-on-ia64">syscalls on ia64</h1>
<p>So what IS the syscall ABI on <strong>ia64</strong>? I never looked into too much details
besides knowing that “it looks very close to calling a C function”. Is it
true though?</p>
<p>Actually, <strong>ia64</strong> has not one but two close but different syscall ABIs:</p>
<ul>
<li><strong>break</strong> instruction based kernel entry (similar to interrupt trap)</li>
<li><strong>epc</strong> magic instruction based (also called <strong>fsys</strong> mode, “fast syscall”)</li>
</ul>
<p><strong>break</strong> ABI is roughly the following:</p>
<ul>
<li>syscall number is placed into <strong>r15</strong> (non-rotating register)</li>
<li>syscall arguments go into rotating registers for output (not input or local)</li>
<li><strong>break 0x10000</strong> is executed to switch into kernel mode via
<strong>break</strong> interrupt vector <strong>ENTRY(break_fault)</strong> (at arch/ia64/kernel/ivt.S)</li>
</ul>
<p>Here argument layout for syscall matches argument layour for a standard C function
on <strong>i64</strong>. Only syscall number is passed via unusual <strong>r15</strong>.</p>
<p><strong>glibc</strong> syscall wrapper fully illustrates typical call:</p>
<pre class><code>ENTRY(syscall)
      /* We are called like so:
         {out0,out1,...,out6} registers -&gt; {NR, arg1, ..., arg6}
         Shift the register window so that {out1...out6} are available
         in {out0...out5} like the kernel syscall handler expects.  */
      alloc r2=ar.pfs,1,0,8,0
      mov r15=r32             /* syscall number */
      break __IA64_BREAK_SYSCALL
      ;;
      cmp.ne p6,p0=-1,r10     /* r10 = -1 on error */
(p6)  ret
      br.cond.spnt.few __syscall_error</code></pre>
<p>Not to go into too many details <strong>syscall’s</strong> proto is <strong>syscall(NR, arg1, arg2, arg3,…,arg8)</strong>
and kernel handles it as <strong>sys_NR(arg1,arg2,arg3,…,arg8)</strong>.</p>
<p>At this point I thought, “aha! off-by-one!”. But tracing through all the paths
of <strong>ia64</strong> assembly I was not able to find any problems. I had to read on stack
handling in branch calls and interrupts in excellent software development intel’s
manual to make sure I don’t miss any special cases. Nothing stood out.</p>
<p>Adding more debugging I realized <strong>break</strong> mechanism was not used at all
in failing cases!</p>
<p>After a bit of debugging I discovered that most of glibc syscalls are
actually done via <strong>epc</strong> (not <strong>break</strong>) mechanism! Gah! I never had
a chance to have a closer look at it and always assumed it’s an unimplemented
feature. So much for being a local expert in <strong>ia64-linux</strong> :D</p>
<p><strong>epc</strong> ABI is unusual: <strong>epc</strong> instruction (Enter Privileged Code)
itself does only one thing: it changes privileges of current execution from
userspace to kernel level and executes next instruction right after it.
This means no context switch, no traps executed. It’s almost like a <strong>nop</strong>.
next few instructions after <strong>epc</strong> need to manually perform all the necessary
context operations. Which might be none for simplest syscalls like <strong>getpid()</strong>!</p>
<p>If userspace could call <strong>epc</strong> from anywhere that would be a good way
to negate any kernel protection. Thus CPU has a few restrictions: code page
with <strong>epc</strong> needs to be marked as privileged for MMU so kernel could provide
safe code that is not easy to turn into an arbitrry privilege escalation</p>
<p>In practice kernel provides such a page as part of <strong>vDSO</strong>. <strong>linux</strong> calls it
<strong>GATE</strong> page. <strong>glibc</strong> finds the <strong>vDSO</strong> out and uses it as syscall
implementation. Linux calls the whole ABI an <strong>fsys</strong> mechanism:
<a href="https://www.kernel.org/doc/html/latest/ia64/fsys.html">https://www.kernel.org/doc/html/latest/ia64/fsys.html</a></p>
<p>The <strong>__kernel_syscall_via_epc()</strong> kernel entry in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/ia64/kernel/gate.S#n300">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/ia64/kernel/gate.S#n300</a>
looks roughly like that:</p>
<pre class><code>GLOBAL_ENTRY(__kernel_syscall_via_epc)
  .prologue
  .altrp b6
  .body
  /*
   * Note: the kernel cannot assume that the first two instructions in this
   * bundle get executed.  The remaining code must be safe even if
   * they do not get executed.
   */
  adds r17=-1024,r15       // A
  mov r10=0                // A default to successful syscall execution
  epc                      // B causes split-issue
  ;;
  RSM_PSR_BE_I(r20, r22)   // M2 (5 cyc to srlz.d)
  LOAD_FSYSCALL_TABLE(r14) // X
  ...</code></pre>
<h1 id="the-argument-layout-bug">the argument layout bug</h1>
<p>Digging through <strong>break</strong> vs. <strong>epc</strong> mechanism I found that <strong>ptrace()</strong>
gets the syscall register frame in slightly different states:</p>
<p>for <strong>break</strong> the layout is:</p>
<pre class><code>outputs:
- arg8
- arg7
- arg6
- ...
- arg1

locals:
&lt;none&gt;

inputs:
- NR</code></pre>
<p><strong>epc</strong>:</p>
<pre class><code>outputs:
- arg8
- arg7
- arg6
- ...
- arg1

locals:
- NR

inputs:
&lt;none&gt;</code></pre>
<p>Both are perfectly valid states prepared to pass arguments to callee function.
And both require a <strong>br.call</strong> instruction to rotate <strong>outputs</strong> to the <strong>inputs</strong>
of callee target.</p>
<p>In normal syscall handling case (without <strong>ptrace()</strong> attached) <strong>br.call</strong>
is called for passing the control to syscall handler written in C. All arguments
are present in their <strong>r32,r33,…</strong> locations.</p>
<p>In tracing case <strong>ptrace()</strong> is executed right before <strong>br.call</strong>. There we
need to inspect syscall arguments (and possibly modify on user’s request)
in <strong>outputs regs</strong> part of the active register set.</p>
<p>The bug was in the fact that <strong>ia64</strong>-specific <strong>ptrace()</strong> code assumed that
locals are never present (as in <strong>break</strong> <strong>glibc</strong>’s wrapper case).</p>
<p>Once we know the problem the fix is easy: skip locals and always use <strong>output</strong>
regs when inspecting syscall arguments:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0ceb1ace4a2778e34a5414e5349712ae4dc41d85">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0ceb1ace4a2778e34a5414e5349712ae4dc41d85</a></p>
<p>Tl;DR of a patch: <strong>ia64</strong> has a <strong>cr.ifs</strong> register that tells us how many
inputs, local and output regusters are used in current function (register’s
value is maintained by <strong>alloc</strong> and <strong>br.call</strong> / <strong>br.ret</strong> instructions).
Before the change we collected both <strong>locals</strong> + <strong>outputs</strong>, after the change - only <strong>outputs</strong>.</p>
<p>Are we done?</p>
<h1 id="the-error-handling-bug">the error handling bug</h1>
<p>After the above patch applied I ran the <strong>strace</strong> test suite again.
It was a lot healtier with just a few failures. This time the error was in
syscall exit code (also new addition) of <strong>ptrace(PTRACE_SYSCALL_INFO_EXIT)</strong>.
This time sign of <strong>errno</strong> error was wrong.</p>
<p>Here we have a chance to see how <strong>ia64</strong> syscalls return status back to userspace:
two fixed registers are used for that:</p>
<ul>
<li><strong>r10</strong> for fail-or-not status</li>
<li><strong>r8</strong> for status-or-error.</li>
</ul>
<p>Here is the original code to set and get the status:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">long</span> syscall_get_error<span class="op">(</span><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">,</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                                     <span class="kw">struct</span> pt_regs <span class="op">*</span>regs<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> regs<span class="op">-&gt;</span>r10 <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">?</span> regs<span class="op">-&gt;</span>r8<span class="op">:</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">long</span> syscall_get_return_value<span class="op">(</span><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                                            <span class="kw">struct</span> pt_regs <span class="op">*</span>regs<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> regs<span class="op">-&gt;</span>r8<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> syscall_set_return_value<span class="op">(</span><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">,</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                                            <span class="kw">struct</span> pt_regs <span class="op">*</span>regs<span class="op">,</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                                            <span class="dt">int</span> error<span class="op">,</span> <span class="dt">long</span> val<span class="op">)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                <span class="co">/* error &lt; 0, but ia64 uses &gt; 0 return value */</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                regs<span class="op">-&gt;</span>r8 <span class="op">=</span> <span class="op">-</span>error<span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                regs<span class="op">-&gt;</span>r10 <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                regs<span class="op">-&gt;</span>r8 <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                regs<span class="op">-&gt;</span>r10 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>6 lines of code. Simple, eh? Can you spot the error?</p>
<p>Note how <strong>syscall_get_error()</strong> does not remove negation
added in <strong>syscall_set_return_value()</strong>.</p>
<p>The fix was obvious:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=61bf318eac2c13356f7bd1c6a05421ef504ccc8a">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=61bf318eac2c13356f7bd1c6a05421ef504ccc8a</a></p>
<p>Surely done now?</p>
<h1 id="signal-handling-bug">signal handling bug</h1>
<p>A few more test failures revealed another fun bug: signal handlers return
wrong signal masks.</p>
<p>In this case failed tests complained about status of blocked signals
in tracing <strong>rt_sigreturn()</strong> syscall.</p>
<p>When signal is delivered to userspace processes memory stack gets an extra
struct that describes delivered signal and a bit of context (on any arch AFAIU):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sigframe <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> arg0<span class="op">;</span> <span class="co">/* signum */</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> arg1<span class="op">;</span> <span class="co">/* siginfo pointer */</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> arg2<span class="op">;</span> <span class="co">/* sigcontext pointer */</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> __user <span class="op">*</span>handler<span class="op">;</span> <span class="co">/* pointer to the plabel of the signal handler */</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> siginfo info<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sigcontext sc<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sigcontext <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    sigset_t sc_mask<span class="op">;</span> <span class="co">/* signal mask to restore after handler returns */</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Somehow <strong>sc_mask</strong> had unexpected value. Was it incorrectly populated by kernel?</p>
<p><strong>ia64</strong> has two userspace stacks:</p>
<ul>
<li>usual C memory stack (tracked by <strong>r12</strong> register), userspace usually
keps there function-local buffers, variables that don’t fit in registers, etc.</li>
<li>register backing store stack (<strong>ar.bsp</strong> and friends point to it), this area is
managed by CPU to maintain rotating registers contents on <strong>br.call</strong> / <strong>br.ret</strong>.
It’s actually quite hard to interpret it’s contents even in steady state due to
fancy alignment restrictions, boundary framing with NaT marking. It’s memory
is also not synchronized with CPUs view of that memory to speed things up. You
almost never want to mess with it for something like passing a struct around.</li>
</ul>
<p>When it’s in <strong>rt_sigreturn()</strong> syscall return that is the simplest way to look at
sigframe on stack. Where stack is present as one of <strong>struct ptrace_syscall_info</strong>
fields:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ptrace_syscall_info <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    __u8 op<span class="op">;</span>        <span class="co">/* Type of system call stop */</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    __u32 arch<span class="op">;</span>     <span class="co">/* AUDIT_ARCH_* value; see seccomp(2) */</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    __u64 instruction_pointer<span class="op">;</span> <span class="co">/* CPU instruction pointer */</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    __u64 stack_pointer<span class="op">;</span>    <span class="co">/* CPU stack pointer */</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="op">{</span>    <span class="co">/* op == PTRACE_SYSCALL_INFO_ENTRY */</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            __u64 nr<span class="op">;</span>       <span class="co">/* System call number */</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            __u64 args<span class="op">[</span><span class="dv">6</span><span class="op">];</span>  <span class="co">/* System call arguments */</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> entry<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="op">{</span>    <span class="co">/* op == PTRACE_SYSCALL_INFO_EXIT */</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            __s64 rval<span class="op">;</span>     <span class="co">/* System call return value */</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            __u8 is_error<span class="op">;</span>  <span class="co">/* System call error flag;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">                               Boolean: does rval contain</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">                               an error value (-ERRCODE) or</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">                               a nonerror return value? */</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> exit<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="op">{</span>    <span class="co">/* op == PTRACE_SYSCALL_INFO_SECCOMP */</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            __u64 nr<span class="op">;</span>       <span class="co">/* System call number */</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            __u64 args<span class="op">[</span><span class="dv">6</span><span class="op">];</span>  <span class="co">/* System call arguments */</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            __u32 ret_data<span class="op">;</span> <span class="co">/* SECCOMP_RET_DATA portion</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">                               of SECCOMP_RET_TRACE</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">                               return value */</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> seccomp<span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>So which of two stacks should be present in <strong>stack_pointer</strong> field? <strong>r12</strong>
or <strong>ar.bspstore</strong>? As a result
our frame is something like that:</p>
<pre class><code>+-------
| ... &lt;registers for outer functions, their cfm, predicates&gt;
+-------
| ... &lt;- ar.bspstore
+-------
| ... &lt;- ar.bsp
| vvv grows down vvv
|
|
| ^^^ grows up ^^^
~~~~~~~~
| ... &lt;- r12
| &lt;signal frame&gt;
| &lt;16-bytes of scratch area&gt;
| &lt;rest of memory stack&gt;
+-------</code></pre>
<p>Kernel had to pick one and picked wrong <strong>ar.bspstore</strong>. It contains no
valid data at all. It consists of leftover values for previous register
flushes and loads.</p>
<p>As a result <strong>ptrace()</strong> looked at a part of register backing store to look up <strong>rt_sigreturn()</strong>.</p>
<p>Once this mismatch became clear the fix was obvious:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7ad1e366167837daeb93d0bacb57dee820b0b898">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7ad1e366167837daeb93d0bacb57dee820b0b898</a></p>
<p>By then strace testsuite passed all tests o/</p>
<p>Can we cautiosly declare the endeavour done?</p>
<h1 id="plot-twist">plot twist</h1>
<p>Well, strace test suite now started hanging whole box on almost every
testsuite run. Looks like before it did not manage to get that far to destroy
kernel’s internal state. Example crash:</p>
<pre class><code>Unable to handle kernel NULL pointer dereference (address 0000000000000338)
sock_filter-v-X[6171]: Oops 11012296146944 [18]
Modules linked in: usb_storage e1000 acpi_ipmi ipmi_si ipmi_devintf ipmi_msghandler rtc_efi

CPU: 0 PID: 6171 Comm: sock_filter-v-X Tainted: G    B D W         5.12.0-rc2-00003-g97669c51470e-dirty #85
Hardware name: hp server rx3600                   , BIOS 04.03                                                            04/08/2008
psr : 0000121008026010 ifs : 800000000000040b ip  : [&lt;a00000010008d1f1&gt;]    Tainted: G    B D W         (5.12.0-rc2-00003-g97669c51470e-dirty)
ip is at ptrace_stop+0x2b1/0x860
unat: 0000000000000000 pfs : 000000000000040b rsc : 0000000000000003
rnat: 0000000000000000 bsps: 0000000000000000 pr  : 000000255aa66a15
ldrs: 0000000000000000 ccv : 00000000fffffa92 fpsr: 0009804c0270033f
csd : 0000000000000000 ssd : 0000000000000000
b0  : a00000010008d1b0 b6  : a0000001008b1b20 b7  : a00000010000d010
f6  : 000000000000000000000 f7  : 1003e8208208208208209
f8  : 1003effffffffffffffea f9  : 1003e0000000000000033
f10 : 1003e8208208208208209 f11 : 1003effffffffffffffe6
r1  : a000000101906440 r2  : 0000000000000010 r3  : 0000000000000000
r8  : 00000000b3a0d9d1 r9  : 00000000000059d0 r10 : 00000000b3a08001
r11 : 0000000000000001 r12 : e00000010f2d5880 r13 : e00000010f2d0000
r14 : a0000001015c8304 r15 : 00000000deaf1eed r16 : e00000010f2d0000
r17 : e00000010f2d100c r18 : a000000101706e70 r19 : e00000010f2d0018
r20 : 0000000000010289 r21 : e00000010f2d0450 r22 : 0000000000000000
r23 : 0000000000000338 r24 : 000000000000b3a2 r25 : 000000000000b3a2
r26 : e00000010f2d048c r27 : 0000000000010013 r28 : fffffffffff7ffff
r29 : 0000000000120000 r30 : 0000000000000000 r31 : e00000010f2d100c

Call Trace:
 [&lt;a000000100014d10&gt;] show_stack+0x90/0xc0
                                sp=e00000010f2d54b0 bsp=e00000010f2d3738
 [&lt;a000000100015410&gt;] show_regs+0x6d0/0xa40
                                sp=e00000010f2d5680 bsp=e00000010f2d36c8
 [&lt;a0000001000285e0&gt;] die+0x1e0/0x3c0
                                sp=e00000010f2d56a0 bsp=e00000010f2d3688
 [&lt;a00000010005b160&gt;] ia64_do_page_fault+0x820/0xb80
                                sp=e00000010f2d56a0 bsp=e00000010f2d35e8
 [&lt;a00000010000ca00&gt;] ia64_leave_kernel+0x0/0x270
                                sp=e00000010f2d56b0 bsp=e00000010f2d35e8
 [&lt;a00000010008d1f0&gt;] ptrace_stop+0x2b0/0x860
                                sp=e00000010f2d5880 bsp=e00000010f2d3590
 [&lt;a00000010008d8a0&gt;] ptrace_do_notify+0x100/0x120
                                sp=e00000010f2d5880 bsp=e00000010f2d3560
 [&lt;a00000010008d950&gt;] ptrace_notify+0x90/0x1a0
                                sp=e00000010f2d58c0 bsp=e00000010f2d3540
 [&lt;a000000100073700&gt;] do_exit+0x1540/0x1700
                                sp=e00000010f2d58c0 bsp=e00000010f2d34c8
 [&lt;a0000001000287b0&gt;] die+0x3b0/0x3c0
                                sp=e00000010f2d58d0 bsp=e00000010f2d3488</code></pre>
<p>It’s a <strong>NULL</strong> pointer dereference. How hard could it be to nail down and fix
(or at least workaround)?</p>
<p>To make the box less unstable I sprintled a few <strong>if (p == NULL) { WARN_ON(1); return; }</strong>
around. That allowed surviving a few strace testsuite runs in a row. Woohoo!</p>
<p><strong>guppy</strong> was able to survive a few days and then crashed with even more dire
and inscrutable panic.</p>
<p>Before digging into more details I first synced to latest kernel git to ease
upstreaming things bit by bit and using Latest and Greatest code.</p>
<p>Surprisingly latest <strong>linux.git</strong> did not even boot.</p>
<p>One of failures Jens quickly fixed right after successful bisection related
to task-level flag handling:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f5f4fc4649ae542b1a25670b17aaf3cbb6187acc">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f5f4fc4649ae542b1a25670b17aaf3cbb6187acc</a></p>
<p>Another failure was use of atomics against unaligned <strong>bool</strong> struct field
in a <strong>hpsa</strong> disk driver, was also easy to fix with help of Don and others:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=02ec144292bc424a5800d45d4cb472c66e97c520">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=02ec144292bc424a5800d45d4cb472c66e97c520</a></p>
<p>I was “lucky” to find those failures before another kernel release (or another
few years of negligence).</p>
<p>Latest <strong>linux.git</strong> was still crashing the box.</p>
<h1 id="more-kernel-debugging">more kernel debugging</h1>
<p>As a next step I enabled everything I could find related to memory corruption
debugging in linux kernel:</p>
<ul>
<li><strong>CONFIG_VM_DEBUG</strong></li>
<li><strong>page_poison=on</strong></li>
<li><strong>init_on_alloc=1</strong> <strong>init_on_free=1</strong></li>
<li><strong>page_owner=on</strong></li>
<li><strong>hardened_usercopy=1</strong></li>
<li><strong>memblock=debug</strong></li>
<li>various slab debugs</li>
</ul>
<p>As a result I got kernel to unbootable state /o\.</p>
<p>I hoped boot failures were related to underlying problem I observed.
One of the annoyances was that kernel silently crashed and did not
print errors to BMC’s serial output. I disabled most of debugging
flags back and left <strong>page_poison=on</strong> <strong>init_on_alloc=1</strong> <strong>init_on_free=1</strong>.</p>
<p>This allowed catching and fixing some minor warnings like:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2a419cf495f95cac49ea289318b833477e1a0e2">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2a419cf495f95cac49ea289318b833477e1a0e2</a>.</p>
<p>After a while (about a day) I started seeing the reports of arbitrarily corrupted
memory:</p>
<pre class><code>pagealloc: memory corruption
000000004a763954: 05 00 00 00 00 00 00 00 f8 b5 b0 ff ff 0f 00 60  ...............`
00000000b3626ed1: 60 b7 b0 ff ff 0f 00 60 50 68 1c 00 08 00 00 20  `......`Ph.....
00000000f59604da: 00 00 00 00 00 00 00 00 00 70 00 00 00 00 00 00  .........p......
00000000345d9313: e3 c2 9b 14 00 00 00 00 aa aa aa aa aa aa aa aa  ................
00000000d092c8b5: aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa  ................
...
0000000088df4d5c: aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa  ................
00000000f6e761a6: aa aa aa aa aa aa aa aa 45 78 63 65 65 64 65 64  ........Exceeded
0000000000d45288: 20 4d 61 78 53 74 61 72 74 75 70 73 0d 0a 00 aa   MaxStartups....
00000000c40693de: aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa  ................
00000000cf8ee6dc: aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa  ................
...
000000005fa7b069: aa aa aa aa aa aa aa aa 10 00 00 00              ............
CPU: 1 PID: 25234 Comm: sshd Not tainted 5.12.0-rc2-00010-gd6be88a244a9-dirty #125
Hardware name: hp server rx3600                   , BIOS 04.03                                                            04/08/2008

Call Trace:
 [&lt;a000000100015210&gt;] show_stack+0x90/0xc0
 [&lt;a000000101161760&gt;] dump_stack+0x150/0x1c0
 [&lt;a0000001003f17b0&gt;] __kernel_unpoison_pages+0x3f0/0x400
 [&lt;a0000001003c1dc0&gt;] get_page_from_freelist+0x1460/0x2ca0
 [&lt;a0000001003c6540&gt;] __alloc_pages_nodemask+0x3c0/0x660
 [&lt;a0000001003ecfd0&gt;] alloc_pages_vma+0xb0/0x500
 [&lt;a000000100375580&gt;] wp_page_copy+0xe0/0x15e0
 [&lt;a0000001003799b0&gt;] do_wp_page+0x170/0xa00
 [&lt;a00000010037e0e0&gt;] __handle_mm_fault+0x1960/0x1fe0
 [&lt;a00000010037ea70&gt;] handle_mm_fault+0x310/0x4e0
 [&lt;a00000010005da50&gt;] ia64_do_page_fault+0x1f0/0xb80
 [&lt;a00000010000ca00&gt;] ia64_leave_kernel+0x0/0x270</code></pre>
<p>Yay! Maybe that’s it?</p>
<p>The backtrace tells us it’s a page fault handling code faulting in a page that
used to be in page freelist, but it’s already in a corruptted state: it should
be full of <strong>aa</strong> values, but it clearly has some unrelated data like
<strong>Exceeded MaxStartups</strong>.</p>
<p>I prepared for a deep dive into virtual memory management in *<em>linux</em>:</p>
<ul>
<li>got basic understanding of page fault handling on <strong>ia64</strong>, <strong>TLB</strong> population
(<strong>VHPT</strong>, <strong>TR</strong>, and <strong>TC</strong> registers management)</li>
<li>got basic understanding of memory management layout on <strong>ia64</strong>: where linear
mapping starts (aka “identity” + base offset), where vmalloc() starts it’s
address, how and when it gets freed</li>
<li>got basic understanding of linux 3-4-5 level page tables are maintained
and synced back to architecture-specific <strong>TLB</strong>.</li>
</ul>
<p>And after much debugging I found that this corruption is a bug in debugging
mechanism /o\</p>
<p><strong>init_on_alloc=1</strong>, <strong>init_on_free=1</strong> and <strong>page_poison=on</strong> are in direct
conflict (and a bit of redundancy) with each other:</p>
<ul>
<li>redundancy: if you have freed a page on <strong>init_on_free=1</strong> system then memory
page can be allocated without <strong>memset(0)</strong> even on <strong>init_on_alloc=1</strong> system
because <strong>init_on_free=1</strong> already guarantees it!</li>
<li>conflict: <strong>init_on_free=1</strong> does <strong>memset(0)</strong> while <strong>page_poison=1</strong> does <strong>memset(aa)</strong>.
Which one has more priority?</li>
</ul>
<p>The problem was that <strong>init_on_alloc=1</strong> + <strong>init_on_free=1</strong> + <strong>debug_pagealloc=1</strong>
led to page freeing with <strong>memset(aa)</strong> and allocation without any <strong>memset()</strong> at all.
This caused two problems:</p>
<ul>
<li>reports on corruption where it should not be</li>
<li>return pages with garbage data to the system even if system requested <strong>alloc_page(__GFP_ZERO)</strong></li>
</ul>
<p>In our case <strong>alloc_page(__GFP_ZERO)</strong> was used for page table (<strong>PTE</strong>) allocations
and instead of returning <strong>PTE</strong> of no pages it was full of bits that looked like
pointers to other pages.</p>
<p>Once this conflict was understood it was easy to report the bug and fix
it with help of <strong>mm</strong> folks:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9df65f522536719682bccd24245ff94db956256c">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9df65f522536719682bccd24245ff94db956256c</a></p>
<p>There are many nuances when exactly the bug could happen. For example architecture must
not support <strong>CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC</strong> (<strong>x86_64</strong> was not
affected by the bug). Otherwise different mechanisms kick in.</p>
<p>On a positive side a few month later I managed to fix a mirror image bug
on <strong>x86_64</strong>:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=69e5d322a2fb86173fde8bad26e8eb38cad1b1e9">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=69e5d322a2fb86173fde8bad26e8eb38cad1b1e9</a></p>
<p>I’ll spare you the details why there is a complication of handling static keys
and early parameters in a way that it could go out of sync like that.</p>
<h1 id="another-yak-page_owner">another yak: page_owner</h1>
<p>Linux kernel has a very cool facility enabled by both <strong>CONFIG_PAGE_OWNER=y</strong>
and <strong>page_owner=on</strong> boot option. It’s idea is to keep the history of most recent
callers who freed and who allocated the page including full backtrace and
page flags. You can see full state for each page in <strong>/sys/kernel/debug/page_owner</strong>:</p>
<pre class><code># cat /sys/kernel/debug/page_owner
  ...
  Page allocated via order 0, mask 0x12cc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY),
   pid 1, ts 651931156 ns, free_ts 0 ns
  PFN 1049310 type Unmovable Block 1024 type Unmovable Flags 0x8000000000000200(sl
  ab|zone=2)
   get_page_from_freelist+0xa31/0xcd0
   __alloc_pages+0x161/0x2b0
   allocate_slab+0x382/0x420
   ___slab_alloc.constprop.0+0x512/0x730
   __slab_alloc.constprop.0+0x90/0xc0
   kmem_cache_alloc+0x3f2/0x430
   kmem_cache_create_usercopy+0x13e/0x2e0
   kmem_cache_create+0x18/0x20
   khugepaged_init+0x20/0x61
   hugepage_init+0x84/0x131
   do_one_initcall+0x41/0x200
   kernel_init_freeable+0x18e/0x1d6
   kernel_init+0x16/0x110
   ret_from_fork+0x1f/0x30
 ...</code></pre>
<p>Initially I hoped to use <strong>page_owner</strong> to dump at corruption detection time
and at random times when I want to see past page history manually (say,
at NULL-corruption detection time).</p>
<p>The problem was that setting <strong>page_owner=on</strong> rendered <strong>ia64</strong>
unbootable. It happened because on <strong>ia64</strong> stack unwinder requires memory
allocation (and gets into infinite recursion) while on other arches it’s not
required.</p>
<p>Fun fact: actually storing stack trace for page owner itself does require
memory allocation as well (on any architecture). It could have a potential
getting into recursion. <strong>page_owner</strong> code tried to prevent it by scanning
current backtrace for duplicate address entries.</p>
<p>I sidestepped <strong>page_owner=on</strong> recursion by storing single bit in currently running
task: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8e9b16c47680f6e7d6e5864a37f313f905a91cf5">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8e9b16c47680f6e7d6e5864a37f313f905a91cf5</a></p>
<p>It should be slightly faster now.</p>
<p>While I have such a nice corruption reporter I attempted to explore and fix
a few tools available to debug it efficintly:</p>
<ul>
<li>added <strong>page_owner</strong> info reporting on detected page corruption: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f58bd538e6a2deb2bcdfe527d9ed45643348a4e6">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f58bd538e6a2deb2bcdfe527d9ed45643348a4e6</a></li>
<li>fixed <strong>page_owner=on</strong> to work the same as <strong>page_owner=1</strong> (for consistency): <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=608b5d668c8ea6734594a401c9adab4093ad9847">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=608b5d668c8ea6734594a401c9adab4093ad9847</a></li>
<li>fixed ia64-specific symbolizer crash on function descriptors: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=99e729bd40fb3272fa4b0140839d5e957b58588a">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=99e729bd40fb3272fa4b0140839d5e957b58588a</a></li>
</ul>
<h1 id="back-to-strace-killer">back to strace killer</h1>
<p>strace testsuite was still able to kill the box. Example crash looked like:</p>
<pre class><code>Unable to handle kernel paging request at virtual address aaaaaaaaaaaaaab2
swapper/0[0]: Oops 8813272891392 [1]
Modules linked in: acpi_ipmi e1000 usb_storage ipmi_si ipmi_devintf ipmi_msghandler rtc_efi

CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.12.0-rc2-00010-gd6be88a244a9-dirty #129
Hardware name: hp server rx3600                   , BIOS 04.03                                                            04/08/2008
psr : 0000101008026010 ifs : 8000000000000307 ip  : [&lt;a000000100e8e670&gt;]    Not tainted (5.12.0-rc2-00010-gd6be88a244a9-dirty)
ip is at sk_filter_release_rcu+0x70/0x120
unat: 0000000000000000 pfs : 0000000000000895 rsc : 0000000000000003
rnat: 0000000000000468 bsps: 0000000000001000 pr  : 01606a5694556a55
ldrs: 0000000000000000 ccv : 000000001f020f81 fpsr: 0009804c0270033f
csd : 0000000000000000 ssd : 0000000000000000
b0  : a00000010018fd00 b6  : a000000100e8e600 b7  : e00000003f81c740
f6  : 1003e000000000003ae7e f7  : 1003e0000000002813e10
f8  : 1003e0019aba91335cd31 f9  : 1003e0019b4e1e1313911
f10 : 1003e0000038521a57b7f f11 : 1003e0000000000000000
r1  : a0000001019465c0 r2  : a000000200034004 r3  : 00000000aaaaaaaa
r8  : aaaaaaaaaaaaaab2 r9  : a00000010174d0c0 r10 : ffffffffffa3cd70
r11 : a00000010148bec8 r12 : a000000101607ba0 r13 : a000000101600000
r14 : e000000116287718 r15 : a000000200034040 r16 : a000000100e8e600
r17 : e00000010e6dfe80 r18 : a000000101607bc0 r19 : e000000005808fc0
r20 : e00000010e6dfe80 r21 : 0000000000000000 r22 : e00000010e6dfe80
r23 : e00000010e6dfe80 r24 : e000000005808f78 r25 : 0000000000001f04
r26 : 00000000000cf92c r27 : 0000000000000007 r28 : a00000010174dba8
r29 : 0000000000000007 r30 : 0000000000000007 r31 : 000000000000000a

Call Trace:
 [&lt;a000000100015210&gt;] show_stack+0x90/0xc0
 [&lt;a000000100015910&gt;] show_regs+0x6d0/0xa40
 [&lt;a000000100029420&gt;] die+0x1e0/0x3c0
 [&lt;a00000010005e370&gt;] ia64_do_page_fault+0xb10/0xb80
 [&lt;a00000010000ca00&gt;] ia64_leave_kernel+0x0/0x270
 [&lt;a000000100e8e670&gt;] sk_filter_release_rcu+0x70/0x120
 [&lt;a00000010018fd00&gt;] rcu_core+0x8c0/0x1440
 [&lt;a0000001001908a0&gt;] rcu_core_si+0x20/0x40
 [&lt;a000000101182cb0&gt;] __do_softirq+0x230/0x670
 [&lt;a000000100079d60&gt;] irq_exit+0x180/0x220
 [&lt;a000000100013a70&gt;] ia64_handle_irq+0x1b0/0x360
 [&lt;a00000010000ca00&gt;] ia64_leave_kernel+0x0/0x270
 [&lt;a0000001000143f0&gt;] ia64_pal_call_static+0x90/0xc0
 [&lt;a0000001000150c0&gt;] ia64_pal_halt_light.isra.0+0x40/0x80
 [&lt;a000000100016200&gt;] arch_cpu_idle+0x100/0x1c0
 [&lt;a0000001011818a0&gt;] default_idle_call+0xe0/0x140
 [&lt;a0000001000eb530&gt;] do_idle+0x330/0x4e0
 [&lt;a0000001000ebe30&gt;] cpu_startup_entry+0x50/0x80
 [&lt;a00000010116ded0&gt;] rest_init+0x230/0x250
 [&lt;a000000101490e70&gt;] arch_call_rest_init+0x20/0x40
 [&lt;a000000101491ad0&gt;] start_kernel+0xbf0/0xc20
 [&lt;a00000010116dc60&gt;] start_ap+0x760/0x780
Disabling lock debugging due to kernel taint
Kernel panic - not syncing: Fatal exception
---[ end Kernel panic - not syncing: Fatal exception ]---</code></pre>
<p>This time the victim is a <strong>swapper</strong> thread that happens to execute
deferred <strong>sk_filter_release_rcu</strong> execution: strace test allocated <strong>sk_filter</strong>
and someone else failed to free it. Virtual address <strong>aaaaaaaaaaaaaab2</strong> says
that it’s probably an use-after-free case.</p>
<p>Should be simple to debug, right?</p>
<p>As I already spent A Lot of time spelunking through memory management in
<strong>ia64</strong> I dropped a bit of dead code around <strong>DISCONTIGMEM</strong>:
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9187592b96385e5060dfb2b182aa9ec93d5c0332">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9187592b96385e5060dfb2b182aa9ec93d5c0332</a></p>
<p>From now on <strong>ia64</strong> is just a <strong>SPARSEMEM</strong> architecture (or <strong>FLATMEM</strong> if
you are lucky to get contiguous physical address layout, I am not: <strong>rx3600</strong>
has 1TB gap for me).</p>
<p>I minimized <strong>strace</strong> killer example down to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;linux/filter.h&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sock_filter bpf_filter<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        BPF_STMT<span class="op">(</span>BPF_RET<span class="op">|</span>BPF_K<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sock_fprog prog <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter <span class="op">=</span> bpf_filter<span class="op">,</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fd <span class="op">=</span> socket<span class="op">(</span>AF_INET<span class="op">,</span> SOCK_DGRAM<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    setsockopt<span class="op">(</span>fd<span class="op">,</span> SOL_SOCKET<span class="op">,</span> SO_ATTACH_FILTER<span class="op">,</span> <span class="op">&amp;</span>prog<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>prog<span class="op">));</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This crashes guppy in a second (usually takes 8 runs):</p>
<pre class><code>$ gcc bug.c -o bug; while ./bug; do echo again; done</code></pre>
<p>The sample program creates IPv4 socket and attackes BPF program to it.
Kernel crashes at the cleanup time.</p>
<p>Socket filters are special in kernel because they use slightly different
virtual memory freeing policy compared to rest of vmalloc()’ed regions:
it’s called <strong>VM_FLUSH_RESET_PERMS</strong>. This flag should eagerly unmap memory
and eagerly flush <strong>TLB</strong>. From my understanding it’s a security feature
that slightly pessimizes performance and does not affect correctness
(modulo bugs we probably observe here).</p>
<p>To get <strong>ia64</strong> box into a fully stable state I ignore any <strong>VM_FLUSH_RESET_PERMS</strong>
mappings with the following hack:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">--- a/mm/vmalloc.c</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">+++ b/mm/vmalloc.c</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -2214,6 +2214,9 @@ static void vm_remove_mappings(struct vm_struct *area, int deallocate_pages)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    remove_vm_area(area-&gt;addr);</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="va">+   /* workaround mysterious double-free on vmalloc() for bpf. */</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="va">+   return;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    /* If this is not VM_FLUSH_RESET_PERMS memory, no need for the below. */</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    if (!flush_reset)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        return;</span></code></pre></div>
<p>Unfortunately I don’t know yet why crash happens and can only speculate at
this point. I suspect that <strong>mm</strong> code lacks a barrier somewhere that allows
page reuse before <strong>TLB</strong> flush happens.</p>
<p>To be continued.</p>
<h1 id="parting-words">Parting Words</h1>
<p><strong>strace</strong> has a great test suite to detect all sorts of corner cases in linux kernel.</p>
<p>Random factoids:</p>
<ul>
<li><strong>ia64</strong> linux syscalls start from <strong>1024</strong>.</li>
<li><strong>ia64</strong> got even better <strong>ptrace()</strong> support.</li>
<li><strong>page_owner=on</strong> is now usable on <strong>ia64</strong>!</li>
<li>I still did not get to the bottom of it. But it feels I’m very close :)</li>
<li><strong>VM_FLUSH_RESET_PERMS</strong> is a thing.</li>
<li>It took me about 2 months to get some progress on this problem.</li>
<li>It took <strong>guppy</strong> about 350 reboots to recover from machine lockups. I suspect it’s more
than this machine ever saw in it’s previous life.</li>
<li>Debugging tools can corrupt your data sometimes even if original setup is not supposed to.</li>
</ul>
<p>Have fun!</p>

<div class="info">
    Posted on August  7, 2021 by trofi. <a href="mailto:slyich@gmail.com">Email</a>,
    <a href="https://github.com/trofi/trofi.github.io.gen">pull requests or comments</a>
    are welcome!
</div>

        </div>
        <div id="footer">
            powered by <a href="http://jaspervdj.be/hakyll">hakyll</a>
        </div>
    </body>
</html>
