<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>trofi's blog: gcc-12 journey</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/code.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlighting-kate.css" />

        <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
        <link rel="alternate" type="application/rss+xml" href="../feed/rss.xml" title="RSS 2.0" />
        <link rel="shortcut icon" href="../images/favicon.ico" />
    </head>
    <body>
        <div id="header">
            <a href="../">main :: IO ()</a>
        </div>
        <div id="navigation">
            <a href="../">/root</a>
            <a href="../archive.html">/archive</a>
            <a href="../feed/atom.xml">/atom.xml</a>
            <a href="../feed/rss.xml">/rss.xml</a>
        </div>

        <div id="content">
            <h1>gcc-12 journey</h1>

            <p>It’s the end of April. This <a href="https://gcc.gnu.org/releases.html">means</a>
<strong>gcc-12</strong> will likely get released soon.</p>
<p>6 months passed since I wrote about fancy bugs in development versions
of <strong>gcc</strong>. Nowadays I use <a href="https://gcc.gnu.org/pub/gcc/snapshots/LATEST-12/">weekly gcc snapshots</a>
against <strong>nixpkgs</strong> tree. Usually I rebuild just my system against
weekly <strong>gcc</strong> shapshots. But sometimes I build random packages to check
how <strong>gcc</strong> behaves on more exotic code bases. Most of the time
everything Just Works. It would be too boring if things worked all the
time.</p>
<p>Since November 2021 I encountered ~30 <strong>gcc</strong> bugs which
makes it roughly one bug a week. I could hardly handle more than that.</p>
<p>I’ll list most of these bugs below. ICEs (internal compiler errors) are
usually the easiest to find and report. Wrong-code bugs are more
interesting and are also way harder to minimize and report.</p>
<p>I usually get to know a lot more about <strong>gcc</strong> from wrong-code cases.
This time I got only two of them. I’ll start from them.</p>
<h1 id="fipa-modref-strikes-again">-fipa-modref strikes again</h1>
<p><a href="https://gcc.gnu.org/PR103432">ipa/103432</a>: <strong>gcc</strong> miscompiled
<strong>libjxl</strong> in a way that test suite started failing.</p>
<p>I can’t provide a small failure example as the bug requires specific
inline to happen within one compilation.</p>
<p>The effect program result difference when built with <strong>-O0</strong> versus
<strong>-O2</strong>. The test was a floating point workload. Those always have a
potential of being not-a-bug, but an expected precision loss (like
<strong>fma()</strong> precision increase).</p>
<p>It took me a while to reduce original test manually to something that
is still a valid program but is small enough to be able to debug it.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=a70faf6e4df7481c2c9a08a06657c20beb3043de">The fix</a>
tells us what kind of error it was in <strong>gcc</strong>: information about inferred
effects of functions was calculated but not actually used, something
else’s ditails were used. It’s a nasty kind of bugs: things work for
smaller programs and break only in non-trivial scenarios.</p>
<p>I’m glad I spent some time to extract the reproducer.</p>
<h1 id="global-constructors-wrong-code">global constructors wrong code</h1>
<p><a href="https://gcc.gnu.org/PR104031">c++/104031</a>: <strong>gcc</strong> generated
wrong global initializer for <strong>nix</strong>. Minimal example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> vector</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">(){}</span>  <span class="op">~</span>vector<span class="op">(){}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Info <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    vector args<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arity <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> RegisterPrimOp</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="ex">gnu::noipa</span><span class="op">,</span><span class="at"> </span><span class="ex">gnu::noinline</span><span class="op">]]</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    RegisterPrimOp<span class="op">(</span>Info info<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>info<span class="op">.</span>arity <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span class="fu">__builtin_trap</span><span class="op">();</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> RegisterPrimOp <span class="va">s_op</span><span class="op">({</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>args <span class="op">=</span> vector<span class="op">{},</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>arity <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<p>The code’s idea is to always have <strong>arity</strong> initialized to <strong>0</strong>. In
practice <strong>gcc-12</strong> managed to put something else into <strong>arity</strong>:</p>
<pre><code># ok:
$ g++-11.2.0 main.cc -o main -O2 &amp;&amp; ./main

# bad:
$ g++-12.0.0 main.cc -o main -O2 &amp;&amp; ./main
Illegal instruction (core dumped)</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=aeca44768d54b089243004d1ef00d34dfa9f6530">The fix</a>
sheds some light into why it happens: this declaration syntax is special
and it was not handled in some definitions. As a result <strong>arity</strong> was
uninitialized.</p>
<h1 id="type-comparison-ice">type comparison ICE</h1>
<p><a href="https://gcc.gnu.org/PR103279">c++/101715</a>: <strong>gcc</strong> ICE
on clang’s <strong>compiler-rt</strong> library. Minimized example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> <span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  S<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">&amp;</span> bar<span class="op">()</span> <span class="kw">noexcept</span><span class="op">(</span>A<span class="op">::</span>value<span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  S<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">&amp;</span> foo<span class="op">()</span> <span class="kw">noexcept</span><span class="op">(</span>A<span class="op">::</span>value<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> S<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">&amp;</span> S<span class="op">&lt;</span>A<span class="op">&gt;::</span>foo<span class="op">()</span> <span class="kw">noexcept</span><span class="op">(</span>A<span class="op">::</span>value<span class="op">)</span> <span class="op">{}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ g++-12.0.0 -c a.c.cpp -std=c++14
# no crash

$ g++-12.0.0 -c a.c.cpp -std=c++17
a.c.cpp:6:56: internal compiler error: canonical types differ for identical types 'S&lt;A&gt;&amp; (S&lt;A&gt;::)() noexcept (A::value)' and 'S&lt;A&gt;&amp; (S&lt;A&gt;::)() noexcept (A::value)'
    6 | template &lt;class A&gt; S&lt;A&gt; &amp; S&lt;A&gt;::foo() noexcept(A::value) {}
      |                                                        ^
0xc3f6ee comptypes(tree_node*, tree_node*, int)
        ../../gcc-12-20211226/gcc/cp/typeck.c:1558
...</code></pre>
<p>Note that <strong>-std=c++14</strong> is not enough to trigger the failure. <strong>gcc-11</strong>
did change the default from <strong>gnu++14</strong> to <strong>gnu++17</strong>.</p>
<p>Sometimes <strong>gcc</strong> needs to compare types for equality. That usually
happens in template instantiation when closest specialization is picked.
It might sound easy, but the subtlety is in details: template types can
refer to other (possibly not yet defined) template types in their
definition.</p>
<p>When instantiation happens it’s crucial to resolve identical types into
the same canonical type.</p>
<p>In the <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=3abcbf243239f9576a60f4ce7f8ee4b3fa14784b">commit message</a>
Marek added great explataion how canonical types came into divergence.</p>
<h1 id="null-warnings-in-dynamic_cast-expressions">null warnings in dynamic_cast expressions</h1>
<p><a href="https://gcc.gnu.org/PR96003">c++/96003</a>: <strong>gcc</strong> failed to build
<strong>firefox</strong> (due to <strong>-Werror=null</strong>). Minimized example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>A <span class="op">();</span> <span class="op">};</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>B <span class="op">();</span> <span class="dt">void</span> f <span class="op">();</span> <span class="op">};</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f <span class="op">(</span>A <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>p<span class="op">))</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>p<span class="op">)-&gt;</span>f <span class="op">();</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Build error:</p>
<pre><code>$ gcc -O2 -S -Wall t.C
t.C: In function ‘void f(A*)’:
t.C:7:29: warning: ‘this’ pointer is null [-Wnonnull]
    7 |     dynamic_cast&lt;B*&gt;(p)-&gt;f ();
      |                             ^
t.C:2:32: note: in a call to non-static member function ‘void B::f()’
    2 | struct B { virtual ~B (); void f (); };
      |                                ^</code></pre>
<p>This time it’s not an <strong>ICE</strong> but a seemingly reasonable warning.
Ideally original code should be restructured into something simpler, like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>A <span class="op">();</span> <span class="op">};</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>B <span class="op">();</span> <span class="dt">void</span> f <span class="op">();</span> <span class="op">};</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f <span class="op">(</span>A <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    B <span class="op">*</span> b <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>B<span class="op">*&gt;(</span>p<span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>b<span class="op">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        b<span class="op">-&gt;</span>f <span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=df5cf47a978aaeb53fc2b18ff0b22eb4531a27d8">The fix</a>
suppressed warnings for some cases where similar code is generated by
<strong>gcc</strong> itself (instead of being handwritten). More complicated cases
will still issue warnings.</p>
<p>You might need to clean your code up to avoid similar warnings.</p>
<h1 id="vectored-intrinsics-ice">vectored intrinsics ICE</h1>
<p><a href="https://gcc.gnu.org/PR102080">middle-end/102080</a>: <strong>gcc</strong> ICE
on <strong>firefox</strong> build. Minimized example:</p>
<pre class="c+++"><code>// cat dec_reconstruct.cc.cc
#pragma GCC target &quot;avx&quot;
typedef float __m256 __attribute__((__vector_size__(32)));
__m256 _mm256_blendv_ps___Y, _mm256_blendv_ps___M, _mm256_mul_ps___A,
    _mm256_mul_ps___B, IfThenElse___trans_tmp_9;
void IfThenElse(__m256 no) {
  IfThenElse___trans_tmp_9 = __builtin_ia32_blendvps256(
      no, _mm256_blendv_ps___Y, _mm256_blendv_ps___M);
}
#pragma GCC target &quot;avx512vl&quot;
void EncodedFromDisplay() {
  __m256 __trans_tmp_11 = _mm256_mul_ps___A * _mm256_mul_ps___B;
  IfThenElse(__trans_tmp_11);
}</code></pre>
<p>ICE:</p>
<pre><code>$ /tmp/gcc-c/gcc/xg++ -B/tmp/gcc-c/gcc -c dec_reconstruct.cc.cc -O0
# no crash

$ /tmp/gcc-c/gcc/xg++ -B/tmp/gcc-c/gcc -c dec_reconstruct.cc.cc -O2
during RTL pass: expand
dec_reconstruct.cc.cc: In function 'void EncodedFromDisplay()':
dec_reconstruct.cc.cc:10:6: internal compiler error: in expand_insn, at optabs.c:7946
   10 | void EncodedFromDisplay() {
      |      ^~~~~~~~~~~~~~~~~~</code></pre>
<p>The sample is not very readable but it’s essentially a direct call of
<strong>__builtin_ia32_blendvps256()</strong> <strong>AVX</strong> intrinsic. Those usually get
translated 1-to-1 into CPU instructions.</p>
<p>Here the crash happens in <strong>expand_insn()</strong> where middle end expands
<strong>GIMPLE</strong> (C style tree-like representation) into <strong>RTL</strong> (assembly style
instruction-like representation). Assertion complains about unexpected
arguments.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=a26ff83ed07e33c4aa46f3314553c0d15ca21100">The fix</a>
adjusts one of <strong>GIMPLE</strong> simplifiers to not generate invalid <strong>GIMPLE</strong>
around vectored conditionals.</p>
<h1 id="atomics-intrinsics-ice">atomics intrinsics ICE</h1>
<p><a href="https://gcc.gnu.org/PR103268">tree-optimization/103268</a>: <strong>gcc</strong> ICE
on <strong>glib</strong> build. Minimized example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> si<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>test_types <span class="op">(</span><span class="dt">long</span> n<span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">int</span> u2 <span class="op">=</span> __atomic_fetch_xor <span class="op">(&amp;</span>si<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> u2<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ gcc -O2 -S x.c
during GIMPLE pass: fab
x.c: In function ‘test_types’:
x.c:3:1: internal compiler error: in optimize_atomic_bit_test_and, at tree-ssa-ccp.c:3645
    3 | test_types (long n)
      | ^~~~~~~~~~
0x1515c9d optimize_atomic_bit_test_and
    /export/gnu/import/git/gitlab/x86-gcc/gcc/tree-ssa-ccp.c:3645</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=074ee8d9a91d7573c1e8774a22e4e08f923adb18">The fix</a>
suggests the tree matcher had an accident fall-through code.
It was supposed to reject unhandled cases instead of attempting
to generate something nonsensical.</p>
<h1 id="vectored-instructions-selector-ice">vectored instructions selector ICE</h1>
<p><a href="https://gcc.gnu.org/PR103557">target/103557</a>: <strong>gcc</strong> ICE
on <strong>tpm2-tss</strong> build. Minimized example:</p>
<pre><code>struct {
  char sm3_256[32];
} TPMU_HA;
typedef struct {
  short size;
  char buffer[sizeof(TPMU_HA)];
} TPM2B_DIGEST;
typedef struct {
  TPM2B_DIGEST auths[3];
} TSS2L_SYS_AUTH_COMMAND;

void Tss2_Sys_Clear(TSS2L_SYS_AUTH_COMMAND);

void sysContext(void) {
  TPM2B_DIGEST nonce = {};
  TSS2L_SYS_AUTH_COMMAND sessionsDataIn = {{nonce}};
  Tss2_Sys_Clear(sessionsDataIn);
}</code></pre>
<p>ICE:</p>
<pre><code>$ gcc-12.0.0 -O2  -c a.c.c -o a.o
during RTL pass: sched2
a.c.c: In function 'sysContext':
a.c.c:19:1: internal compiler error: Segmentation fault
   19 | }
      | ^
0x1e22687 internal_error(char const*, ...)
        ???:0
0xe7e43c memory_operand(rtx_def*, machine_mode)
        ???:0
0x167e598 get_attr_memory(rtx_insn*)
        ???:0
0x19a4bc0 insn_default_latency_generic(rtx_insn*)
        ???:0
0x1c74ad3 insn_sched_cost(rtx_insn*)
        ???:0
0x1c77934 dep_cost_1(_dep*, unsigned int)
        ???:0
0x1c79d7f set_priorities(rtx_insn*, rtx_insn*)
        ???:0
0xec28e2 compute_priorities()
        ???:0</code></pre>
<p>In this case instruction selector fails to fetch the details
around memory reference accessed by instruction.
<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=9519b694afbf9a35c36cf9f14d35d1c0e9e8cacc">The change</a>
fixes <strong>x86</strong>-specific vectored instruction definitions to accept
expected inputs.</p>
<h1 id="another-atomics-ice">another atomics ICE</h1>
<p><a href="https://gcc.gnu.org/PR103682">tree-optimization/103682</a>: <strong>gcc</strong> ICE
on some cryptographic code. Minimized example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;atomic&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bug<span class="op">(</span><span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">unsigned</span><span class="op">&gt;</span> <span class="op">&amp;</span> ready<span class="op">,</span> <span class="dt">unsigned</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>ready<span class="op">.</span>fetch_and<span class="op">(~</span>u<span class="op">)</span> <span class="op">&amp;</span> u<span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ g++-12.0.0 -Ofast -c bug.cpp
during GIMPLE pass: fab
bug.cpp: In function 'bool bug(std::atomic&lt;unsigned int&gt;&amp;, unsigned int)':
bug.cpp:6:6: internal compiler error: gimple check: expected gimple_assign(error_mark), have gimple_nop() in gimple_assign_rhs_code, at gimple.h:2852
    6 | bool bug(std::atomic&lt;unsigned&gt; &amp; ready, unsigned u) {
      |      ^~~
0x20a58f7 internal_error(char const*, ...)
        ???:0
0x7c76dd gimple_check_failed(gimple const*, char const*, int, char const*, gimple_code, tree_code)
        ???:0</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=a2a0c91b47537b16908981e206f4e42db8425eca">The fix</a>
shows us it was another case where one particular case of <strong>GIMPLE</strong>
form was not handled.</p>
<h1 id="another-template-instantiation-ice">another template instantiation ICE</h1>
<p><a href="https://gcc.gnu.org/PR103769">c++/103769</a>: <strong>gcc</strong> ICE
on <strong>openttd</strong>. Minimized example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">using</span> t <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...&gt;</span> <span class="kw">struct</span> s<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span> s<span class="op">&lt;</span>t<span class="op">&lt;</span>Args<span class="op">&gt;...&gt;</span> f<span class="op">()</span> <span class="op">{</span> f<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;();</span> <span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ g++-12.0.0 --param=hash-table-verification-limit=1000 -O1 -o a.o -c bug.cpp

hash table checking failed: equal operator returns true for a pair of values with a different hash value
bug.cpp: In substitution of 'template&lt;class ... Args&gt; s&lt;Args ...&gt; f() [with Args = {void}]':
bug.cpp:3:56:   required from here
bug.cpp:3:43: internal compiler error: in hashtab_chk_error, at hash-table.c:137
    3 | template &lt;typename... Args&gt; s&lt;t&lt;Args&gt;...&gt; f() { f&lt;void&gt;(); }
      |                                           ^
0x9c316d hashtab_chk_error()
        ../../gcc-12-20220102/gcc/hash-table.c:137
0xbeca15 hash_table&lt;spec_hasher, false, xcallocator&gt;::verify(spec_entry* const&amp;, unsigned int)
        ../../gcc-12-20220102/gcc/hash-table.h:1036
0xbecb6f hash_table&lt;spec_hasher, false, xcallocator&gt;::find_with_hash(spec_entry* const&amp;, unsigned int)
        ../../gcc-12-20220102/gcc/hash-table.h:921
0xbd58bc lookup_template_class_1
        ../../gcc-12-20220102/gcc/cp/pt.c:9905</code></pre>
<p>This is aanother <strong>c++</strong> frontend bug where identical types have
different objects. Here I found out about <strong>--param=hash-table-verification-limit=1000</strong>
option which enables more frequent type mismatches like this.
Without this option the bug disappears when program is still large.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=07be8f8da4c6840a1fd6b2229b147e50cc6f03dc">The change</a>
shows it was a case of reused type object in typedef simplification.</p>
<h1 id="yet-another-vectored-expansion-ice">yet another vectored expansion ICE</h1>
<p><a href="https://gcc.gnu.org/PR103842">target/103842</a>: <strong>gcc</strong> ICE
on <strong>ilmbase-2.5.7</strong>. Minimized example:</p>
<pre><code>void abs(float *);
struct Matrix33 {
  float x[3][3];
  float *operator[](int i) { return x[i]; }
  Matrix33();
  Matrix33(float f, float g) {
    x[1][0] = x[1][1] = x[1][2] = f;
    x[2][0] = g;
  }
  void equalWithAbsError();
  Matrix33 inverse() {
    Matrix33 s(x[1][2] - x[1][2], x[1][1] - x[1][1]);
    float r = s[2][0];
    if (r)
      for (int i = 0; i &lt; 3; ++i)
        for (int j = 0; j &lt; 3; ++j)
          s[i][j] /= r;
    for (int i = 0;;) {
      float *__trans_tmp_2 = s[i];
      abs(__trans_tmp_2);
    }
  }
};
void __assert_fail() {
  Matrix33 m, inv1 = m.inverse(), ident1 = inv1;
  ident1.equalWithAbsError();
}</code></pre>
<p>ICE:</p>
<pre><code>
$ g++-12.0.0 -O3 -c bug.cpp.cpp
during RTL pass: expand
bug.cpp.cpp: In function 'void __assert_fail()':
bug.cpp.cpp:27:5: internal compiler error: Segmentation fault
   27 |     }
      |     ^
0x21196c6 internal_error(char const*, ...)
        ???:0</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=242783c52c22ed96eae722b2fa9847711ac84699">The change</a>
fixes another case of <strong>x86</strong>-specific instruction selector that
generates unexpected instruction parameters.</p>
<h1 id="one-more-vectored-instruction-ice">one more vectored instruction ICE</h1>
<p><a href="https://gcc.gnu.org/PR103894">target/103894</a>: <strong>gcc</strong> ICE
on <strong>valgrind</strong>.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=1096ab1775636f35de9c6661f8f71f03299af998">The change</a>
fixes marking of available SSE instructions in 32-bit mode.</p>
<h1 id="precompiled-headers">precompiled headers</h1>
<p><a href="https://gcc.gnu.org/PR103910">target/103910</a>: <strong>gcc</strong> ICE
on <strong>openjdk</strong>. Minimized example:</p>
<pre><code>#include &quot;precompiled.hpp&quot;
void *operator new(unsigned long, void *__p) { return __p; }
#define MEMORY_TYPES_DO(f) f(mtNone, )
enum MEMFLAGS {};
#define MEMORY_TYPE_SHORTNAME(type, human_readable) MEMFLAGS type;
MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME) struct GrowableArrayView {
  GrowableArrayView(int *, int, int);
};
int *GrowableArrayWithAllocator_data;
struct GrowableArrayWithAllocator : GrowableArrayView {
  GrowableArrayWithAllocator(int initial_max)
      : GrowableArrayView(GrowableArrayWithAllocator_data, initial_max, 0) {
    for (int i = 0; i &lt; initial_max; i++)
      new (&amp;GrowableArrayWithAllocator_data[i]) int();
  }
};
struct GrowableArrayMetadata {
  GrowableArrayMetadata(MEMFLAGS);
};
struct GrowableArray : GrowableArrayWithAllocator {
  GrowableArrayMetadata _metadata;
  GrowableArray(int initial_max)
      : GrowableArrayWithAllocator(initial_max), _metadata(mtNone) {}
};
struct SourceObjList {
  SourceObjList();
};
SourceObjList::SourceObjList() { GrowableArray(128 * 1024); }</code></pre>
<p>ICE:</p>
<pre><code>$ rm -rf ph
$ mkdir -p ph
$ touch precompiled_.hpp # create empty file
$ ./xg++ -B. -O3 -march=opteron -fcheck-new -c precompiled_.hpp -o ph/precompiled.hpp.gch
$ ./xg++ -B. -O3 -march=opteron -fcheck-new -Iph -c archiveBuilder.cpp -o a.o

during GIMPLE pass: aprefetch
archiveBuilder.cpp: In constructor ‘SourceObjList::SourceObjList()’:
archiveBuilder.cpp:28:1: internal compiler error: in gimple_build_call, at gimple.c:267
   28 | SourceObjList::SourceObjList() { GrowableArray(128 * 1024); }
      | ^~~~~~~~~~~~~
0xd2845f gimple_build_call(tree_node*, unsigned int, ...)
        gcc/gimple.c:267
0x12880c8 emit_mfence_after_loop
        gcc/tree-ssa-loop-prefetch.c:1300
0x12880c8 mark_nontemporal_stores
        gcc/tree-ssa-loop-prefetch.c:1359
0x12880c8 loop_prefetch_arrays
        gcc/tree-ssa-loop-prefetch.c:1955
0x12880c8 tree_ssa_prefetch_arrays()
        gcc/tree-ssa-loop-prefetch.c:2031
0x1288be9 execute
        gcc/tree-ssa-loop-prefetch.c:2097</code></pre>
<p>This is an unusual and scary case: precompiled headers are implemented
as a serialization of part of <strong>gcc</strong> heap. The serialization tries
hard to be very fast and cuts corners in various places. Up to the point
where building positional-independent <strong>gcc</strong> binary breaks <strong>GCH</strong>:
<a href="https://gcc.gnu.org/PR71934" class="uri">https://gcc.gnu.org/PR71934</a>. It’s very fragile. It does not have to be.</p>
<p>To make <strong>GCH</strong> somehow work <strong>gcc</strong>’s internals have garbage collector
implementation. It requires global variables to be annotated with
<strong>gcc</strong>-specific <a href="https://gcc.gnu.org/onlinedocs//gccint/GTY-Options.html">GTY markings</a>
that describe heap layout.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=d243f4009d8071b734df16cd70f4c5d09a373769">The change</a>
hints at an <strong>x86_mfence</strong> global variable that did not have the marking.</p>
<p>Why did it break only with <strong>GCH</strong>?</p>
<p>Without <strong>GCH</strong>, <strong>x86_mfence</strong> is referenced via another global object which
has <strong>GTY</strong> marking. Both are constructed via normal means of <strong>gcc</strong>
parsing the source.</p>
<p>With GCH, that another global object is restored at a different location
and the decl that is refenced by <strong>x86_mfence</strong> is GC’ed out.</p>
<h1 id="c-frontend-constructor-ice">C++ frontend constructor ICE</h1>
<p><a href="https://gcc.gnu.org/PR104583">c++/103910</a>: <strong>gcc</strong> ICE
on <strong>dolphin-emu</strong>. Minimized example:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TVec3 <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  TVec3<span class="op">();</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>using Vec3 <span class="op">=</span> TVec3<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  Vec3 position<span class="op">{};</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> EmulatePoint_state<span class="op">;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> EmulatePoint<span class="op">()</span> <span class="op">{</span> EmulatePoint_state <span class="op">=</span> <span class="op">{};</span> <span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ /tmp/gcc/xg++ -B/tmp/gcc -c bug.cc -freport-bug
bug.cc: In function ‘void EmulatePoint()’:
bug.cc:9:42: internal compiler error: in cp_gimplify_expr, at cp/cp-gimplify.cc:746
    9 | void EmulatePoint() { EmulatePoint_state = {}; }
      |                       ~~~~~~~~~~~~~~~~~~~^~~~
0x7a0fb2 cp_gimplify_expr(tree_node**, gimple**, gimple**)
        gcc/cp/cp-gimplify.cc:746
0xd9fb80 gimplify_expr(tree_node**, gimple**, gimple**, bool (*)(tree_node*), int)
        gcc/gimplify.cc:14893
0xdab095 gimplify_init_ctor_preeval
        gcc/gimplify.cc:4678</code></pre>
<p>In this case <strong>gcc</strong> was unable to generate <strong>GIMPLE</strong> out of
<strong>EmulatePoint_state = {};</strong> statement.</p>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=f8c1f29a0b47b4b4a3c1506678f7ca2ce4b7ffbb">The change</a>
expands set of cases that look like a constructor call.</p>
<h1 id="fun-option-handling-bug">fun option handling bug</h1>
<p><a href="https://gcc.gnu.org/PR104705">middle-end/104705</a>: <strong>gcc</strong> ICEs when
tried to build <strong>ghc</strong>.</p>
<p>Normally I would expect <strong>ghc</strong> to be the last project to crash <strong>gcc</strong>
as it does not do anything fancy in C land. And yet here we are.
Minimized example:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma GCC optimize &quot;foo&quot;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma GCC push_options</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma GCC pop_options</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ /tmp/bg/gcc/xgcc -B/tmp/bg/gcc -c a.c  -O2 -Wall
a.c:1:9: warning: bad option ‘-ffoo’ to pragma ‘optimize’ [-Wpragmas]
    1 | #pragma GCC optimize &quot;foo&quot;
      |         ^~~
a.c:3:9: internal compiler error: ‘global_options’ are modified in local context
    3 | #pragma GCC pop_options
      |         ^~~</code></pre>
<p>A cryptic assert.
<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=111754595cf8d3a8ae7063a42ac4cea18a304711">The fix</a>
says that <strong>-g*</strong> option was not accounted for when option contexts are
created and destroyed with pragmas.</p>
<h1 id="unexpected-analyzer-ices">unexpected analyzer ICEs</h1>
<p><a href="https://gcc.gnu.org/PR105074">analyzer/105074</a>: <strong>gcc</strong> ICE when
tried to build <strong>gnutls</strong>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> _gnutls_log<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*);</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> _gnutls_ocsp_verify_mandatory_stapling<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  _gnutls_log<span class="op">(</span>__func__<span class="op">);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> check_ocsp_response_gnutls_x509_cert_verify_peers<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  _gnutls_ocsp_verify_mandatory_stapling<span class="op">();</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ /tmp/gb/gcc/xgcc -B/tmp/gb/gcc -O2 -fanalyzer -c cert-session.c

during IPA pass: analyzer
In function ‘_gnutls_ocsp_verify_mandatory_stapling’,
    inlined from ‘check_ocsp_response_gnutls_x509_cert_verify_peers’ at cert-session.c:7:3:
cert-session.c:4:3: internal compiler error: Segmentation fault
    4 |   _gnutls_log(__func__);
      |   ^~~~~~~~~~~~~~~~~~~~~
0xdd6bc3 crash_signal
        gcc/toplev.cc:322
0x8a8120 cgraph_node::get_edge(gimple*)
        gcc/cgraph.cc:744
0x121059c ipa_ref_requires_tracking
        gcc/analyzer/region.cc:1192
0x121059c symnode_requires_tracking_p
        gcc/analyzer/region.cc:1235
0x121059c ana::decl_region::calc_tracked_p(tree_node*)
        gcc/analyzer/region.cc:1254
0x1234786 ana::decl_region::decl_region(unsigned int, ana::region const*, tree_node*)</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=1203e8f7880c9751ece5f5302e413b20f4608a00">The change</a>
adjusts the checks for expressions without explicit declaration.</p>
<p>On a surface side it’s an obscure <strong>-fanalyzer</strong> crash on <strong><strong>func</strong></strong>
expression that should not pop up frequently. Perhaps <strong>gnutls</strong> is a
rare package that enables <strong>-fanalyser</strong>?</p>
<p>No. If we look at the source of <strong>-fanalyzer</strong> flag we’ll find that it’s
one of default warnings of … <a href="https://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=3831e2e9f355c557b0c0ed9712548b62feaf694f"><strong>gnulib(!)</strong></a>.</p>
<p>We will probably see a lot more analyser crashes as it’s one of the
more complex pieces of <strong>gcc</strong>.</p>
<h1 id="ia64-rtl-mach-ice">ia64 RTL mach ICE</h1>
<p><a href="https://gcc.gnu.org/PR105215">target/105215</a>: <strong>gcc</strong> ICE
on <strong>openssl</strong> (<strong>ia64</strong> target).</p>
<p>Not fixed yet.</p>
<h1 id="ia64-rtl-mach-ice-1">ia64 RTL mach ICE</h1>
<p><a href="https://gcc.gnu.org/PR105247">target/105247</a>: <strong>gcc</strong> ICE
on <strong>sqlite-3.38.2</strong> (<strong>ia64</strong> target). Minimal example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sqlite3CodeVerifySchemaAtToplevel_pToplevel_0<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sqlite3CodeVerifySchema<span class="op">();</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sqlite3FindInIndex_pParse<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i <span class="op">=</span> <span class="op">-</span><span class="dv">8</span><span class="op">;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  sqlite3CodeVerifySchema<span class="op">(</span>sqlite3FindInIndex_pParse<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sqlite3CodeVerifySchema<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span> iDb<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  sqlite3CodeVerifySchemaAtToplevel_pToplevel_0 <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> iDb<span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ICE:</p>
<pre><code>$ ia64-unknown-linux-gnu-gcc -O1 -c sqlite3-sqlite3.o.c -o a.o

during RTL pass: cse1
sqlite3-sqlite3.o.c: In function 'sqlite3FindInIndex_pParse':
sqlite3-sqlite3.o.c:7:1: internal compiler error: in decompose, at rtl.h:2288
    7 | }
      | ^
0xa02263 wi::int_traits&lt;&gt;::decompose()
        ../../gcc-12-20220410/gcc/rtl.h:2288
0xa02263 wide_int_ref_storage&lt;&gt;::wide_int_ref_storage&lt;&gt;()
        ../../gcc-12-20220410/gcc/wide-int.h:1024
0xa02263 generic_wide_int&lt;&gt;::generic_wide_int&lt;&gt;()
        ../../gcc-12-20220410/gcc/wide-int.h:782
0xa02263 wide_int_storage::wide_int_storage&lt;&gt;()</code></pre>
<p><a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=ba2f60499dd4a3bc1bb4e99fa12dda3bc1548519">The change</a>
has a great explanation of the details by Jakub: arithmetic shift
(to implement <strong>1 &lt;&lt; iDb</strong>) on <strong>ia64</strong> is slightly different from
other targets: it’s defined only for 64-bit type (<strong>long</strong> /
<strong>unsigned ulong</strong> types).</p>
<h1 id="popcount-and-libgcc">popcount and libgcc</h1>
<p><a href="https://gcc.gnu.org/PR105253">middle-end/105253</a>: <strong>gcc</strong> fails
to build <strong>linux</strong>. Minimal example:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>foo <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i<span class="op">,</span> cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> elem<span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">(</span><span class="dv">256</span> <span class="op">/</span> <span class="dv">64</span><span class="op">);</span> i<span class="op">++)</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>      elem <span class="op">=</span> p<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(;</span> elem<span class="op">;</span> cnt<span class="op">++)</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        elem <span class="op">&amp;=</span> elem <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cnt<span class="op">;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Link error:</p>
<pre><code>ERROR: modpost: &quot;__popcountdi2&quot; [drivers/net/ethernet/broadcom/bnx2x/bnx2x.ko] undefined!
ERROR: modpost: &quot;__popcountdi2&quot; [drivers/gpu/drm/amd/amdgpu/amdgpu.ko] undefined!</code></pre>
<p>Long time ago <strong>gcc</strong> used to produce direct CPU instructions to
implement this code. Nowadays <strong>gcc</strong> recognises this pattern
and converts it to a <strong>__builtin_popcountl()</strong> call.</p>
<p>If CPU supports <strong>popcnt</strong> instruction then <strong>gcc</strong> emits it as is.
But if CPU has no support for it <strong>gcc</strong> generates <strong>__popcountdi2</strong>
external function call. <strong>__popcountdi2</strong> is implemented in <strong>libgcc</strong>
for all targets.</p>
<p>Normally such a replacement just works. But linux kernel does not use <strong>libgcc</strong> for
various rasons and prefers to re-implement such builtins (division,
shifts, memcpy, strlen operations). But <strong>popcout</strong> ones did not
occur frequently enough to be re-implemented in kernel.</p>
<p>One of the fixes would be to extend linux kernel with <strong>popcount</strong>.
But so far <strong>gcc</strong>
<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=29c46490de4616b911fccb34a9479f768fb51e94">tweaked</a>
cost heuristics to avoid such conversion for targets that don’t have
efficient <strong>popcnt</strong>.</p>
<p>Until next time perhaps :)</p>
<h1 id="parting-words">Parting words</h1>
<p>Most of these bugs are short-lived and would have no chance to slip
into a release. Most ICEs are also not hard to workaround when
encountered.</p>
<p>The wrong-code bugs are the subtlest. These usually live for a while
until they get noticed.</p>
<p>Bug stats by subsystem:</p>
<ul>
<li>6 <strong>target</strong>: 3 vectorisation bugs, 2 <strong>ia64</strong> bugs, 1 <strong>GCH</strong> bug</li>
<li>5 <strong>c++</strong> frontend</li>
<li>3 <strong>middle-end</strong>: vectorisation, option parsing and popcount instruction one bug each</li>
<li>2 <strong>tree-opt</strong>: both are atomics bugs</li>
<li>1 <strong>ipa</strong></li>
<li>1 <strong>analyzer</strong></li>
</ul>
<p>If not for <strong>ia64</strong> bugs <strong>c++</strong> would be the primary source of bugs.</p>
<p><strong>gcc-12</strong> is very close to a release cut date. I hope it to be smooth.</p>
<p>As usual here is a list if notable changes for upcoming release:
<a href="https://gcc.gnu.org/gcc-12/changes.html" class="uri">https://gcc.gnu.org/gcc-12/changes.html</a></p>
<p>If you feel like it do give the <strong>gcc</strong> snapshot a try.</p>
<p>Have fun!</p>

<div class="info">
    Posted on April 24, 2022 by trofi. <a href="mailto:slyich@gmail.com">Email</a>,
    <a href="https://github.com/trofi/trofi.github.io.gen">pull requests or comments</a>
    are welcome!
</div>

        </div>
        <div id="footer">
            powered by <a href="http://jaspervdj.be/hakyll">hakyll</a>
        </div>
    </body>
</html>
